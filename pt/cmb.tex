\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

\usepackage[brazil]{babel}   \usepackage[latin1]{inputenc}  

\graphicspath{{./figuras/}}
     
\sloppy

\hyphenation{re-la-xa-do re-pre-sen-ta Facebook}

\title{Desempenho de Sistemas com Dados Georeplicados\\ com Consistência em
Momento Indeterminado e\\ na Linha do Tempo}

\author{Mauricio De Diana\inst{1}, Marco Aurélio Gerosa\inst{1}}

\address{Instituto de Matemática e Estatística -- Universidade de São Paulo
(USP)\\ \email{\{mdediana,gerosa\}@ime.usp.br}}

\begin{document} 

\maketitle

\begin{abstract} This meta-paper describes the style to be used in articles and
short papers for SBC conferences. For papers in English, you should add just an
abstract while for the papers in Portuguese, we also ask for an abstract in
Portuguese (``resumo''). In both cases, abstracts should not have more than 10
lines and must be in the first page of the paper.  \end{abstract}
     
\begin{resumo}

Replicação de dados entre diferentes centros de dados é usada por sistemas web
de larga escala para atingir altos níveis de desempenho e disponibilidade. Um
modelo de consistência define o balanço entre esses dois requisitos e a
consistência dos dados entre réplicas. Este trabalho comparou experimentalmente
o desempenho de um sistema de armazenamento georeplicado usando consistência em
momento indeterminado e consistência na linha do tempo. As medições mostraram
que, dependendo da carga de trabalho e das condições de rede, os desempenhos
desses modelos de consistência são semelhantes. Esse resultado pode auxiliar
responsáveis por sistemas web de larga escala a estimar custos de
desenvolvimento e fazer planejamento de capacidade.

\end{resumo}

%% ------------------------------------------------------------------------- %%
\section{Introdução} \label{sec:introducao}

Para atender centenas de milhares de usuários ininterruptamente em sistemas web
de larga escala, dados são replicados em milhares de servidores distribuídos em
múltiplos centros de processamento de dados em diferentes localizações
geográficas. O principal problema do uso de replicação em redes de longa
distância (WAN) é que manter as réplicas sempre consistentes entre si
tipicamente implica em sacrificar outros requisitos também importantes, como
desempenho ou disponibilidade. Um motivo para divergência entre réplicas é que a
replicação entre centros de processamento de dados pode apresentar centenas de
milissegundos de latência, período durante o qual as réplicas podem divergir.
Essa latência é resultado não só das distâncias físicas entre os nós, mas também
de limitações na largura de banda disponível e congestionamento de rede.  Outro
motivo de divergência entre réplicas é a falha temporária de um nó, que deixa de
receber atualizações por um período de tempo. Um terceiro motivo é o
particionamento de rede, causado por exemplo por uma falha em um equipamento ou
enlace de rede que impeça a comunicação entre réplicas.

Com isso, desenvolvedores e administradores de sistemas web de larga escala
buscam um balanço entre disponibilidade, desempenho e consistência dos dados.
Uma decisão comum em vários desses sistemas é o relaxamento da consistência em
troca de alta disponibilidade e baixa latência. Por outro lado, modelos de
consistência mais relaxados permitem que conflitos entre réplicas aconteçam.
Com isso, o código da aplicação fica mais complexo pois mecanismos de resolução
de conflitos e ações de compensação precisam ser implementados.

Este trabalho é um comparativo de desempenho de um sistema de armazenamento
georeplicado usando dois modelos de consistência diferentes. Um deles, a
consistência em momento indeterminado (\emph{eventual consistency}\footnote{O
termo \emph{eventual consistency} às vezes é erroneamente traduzido para o
português como consistência eventual. Mas \emph{eventual} é um falso cognato, já
que em inglês ele indica que algo certamente acontecerá no futuro, mas em
português significa que algo pode ou não acontecer no futuro. Daí a opção de
traduzir \emph{eventual} por ``em momento indeterminado''.}) é um modelo mais
relaxado e se tornou especialmente popular após a publicação sobre o Dynamo da
Amazon \cite{DeCandia2007,Lakshman2010,Riak}. Um modelo de consistência para
sistemas georeplicados menos popular, que busca um meio termo entre consistência
forte e consistência em momento indeterminado é a consistência na linha do
tempo, usada no PNUTS do Yahoo \cite{Cooper2008,Abadi2010}. Ela é uma opção
interessante por simplificar a programação, desde que seu desempenho seja
próximo ao da consistência em momento indeterminado e a aplicação tolere níveis
mais baixos de disponibilidade.

A Seção~\ref{sec:consistencia_em_momento_indeterminado_e_na_linha_do_tempo}
apresenta detalhes dos modelos de consistência usados no estudo e as situações
que favorecem o uso de cada um deles.

%% ------------------------------------------------------------------------- %%
\section{Consistência em Momento Indeterminado e na Linha do Tempo}
\label{sec:consistencia_em_momento_indeterminado_e_na_linha_do_tempo}

A consistência em momento indeterminado garante que as réplicas vão sempre
convergir em algum momento no futuro desde que novas atualizações cessem.
Enquanto atualizações estiverem acontecendo, réplicas inconsistentes são
possíveis, e clientes podem acessar dados desatualizados ou divergentes - por
isso o sistema precisa implementar algoritmos de detecção e resolução de
conflitos. Uma forma de diminuir as chances de conflitos é o uso de quóruns,
cujo contraponto é a diminuição da disponibilidade do sistema quando um
determinado quórum não é atingido \cite{Vogels2009}. Costuma-se usar os
parâmetros N, R e W para definir os quóruns. N é o fator de replicação e
representa a quantidade de réplicas existentes de um objeto. R é a quantidade de
réplicas que precisam concordar com o mesmo valor para que uma leitura seja bem
sucedida e W possui o mesmo significado, mas para escritas. Quando $N < R + W$,
não existe possibilidade de clientes lerem dados inconsistentes.

Algumas aplicações web tornam-se mais simples com um modelo de consistência mais
rígido. Por exemplo, uma aplicação de leilão não pode permitir conflitos no
histórico de lances de um produto. Num sistema que usa consistência em momento
indeterminado, no caso de uma falha que divida a rede em duas partições,
usuários em cada partição têm uma visão própria do histórico de lances,
equivalente a dois leilões simultâneos sobre o mesmo item.

A consistência na linha do tempo abre mão de disponibilidade em algumas
situações em troca de consistência \cite{Cooper2008}.  Para cada objeto
armazenado, ela permite atualizações em apenas uma de suas réplicas (réplica
mestre). Devido à replicação assíncrona, réplicas podem ter valores
desatualizados devido à latência de rede ou falhas, mas a qualquer instante
sabe-se qual é a réplica com o valor mais recente. Os clientes escolhem em cada
acesso se aceitam como resposta apenas o valor mais recente ou se aceitam
valores desatualizados. Além disso, como a réplica mestre define uma ordem de
aplicação de atualizações nas outras réplicas, divergências não acontecem e
mecanismos de detecção e resolução de conflitos não são necessários. A principal
desvantagem da consistência na linha do tempo é que a existência de uma réplica
mestre implica que escritas e leituras consistentes (leituras do valor mais
recente) ficam indisponíveis em caso de uma falha que impeça o acesso a essa
réplica.

O maior fator de impacto no desempenho da consistência na linha do tempo é o
fato de que operações consistentes que não são feitas no centro de processamento
de dados em que está a réplica mestre incorrem no custo de comunicação pela WAN.
Mas os autores do PNUTS indicam que algumas aplicações no Yahoo apresentam
localidade de até 85\% e relação escrita/leitura de 0,06
\cite{Kadambi2011,Cooper2008}. Dado isso, eles implementaram uma heurística em
que a réplica mestre migra para o centro de processamento de dados que recebeu
as últimas 3 escritas. Dessa forma, em uma aplicação na qual a quantidade de
leituras é muito maior do que a quantidade de escritas, o custo de comunicação
de rede é baixo, em especial se as leituras não precisarem necessariamente do
valor mais recente.

%% ------------------------------------------------------------------------- %%
\section{Planejamento dos Experimentos}
\label{sec:planejamento_dos_experimentos}

Três técnicas são comumente usadas na análise de desempenho de sistemas:
simulação, modelagem analítica e medição \cite{Jain1991}. Dada a grande
quantidade de parâmetros considerados, seria difícil evitar o impacto na
precisão de simplificações necessárias para a criação de simuladores ou modelos,
portanto medição foi escolhida.

Foi necessário escolher um sistema como objeto do estudo. Como não foram
encontradas soluções de software livre com consistência na linha do tempo, a
opção foi implementá-la em um sistema com consistência em momento indeterminado,
no caso, o Riak. Além do novo modelo de consistência, também foi implementado um
algoritmo de particionamento que garante que existe ao menos uma réplica em cada
centro de processamento de dados.

Como \emph{benchmark}, foi usado o Basho Bench, específico para Riak. Ele foi
adaptado para executar instâncias em nós diferentes, uma para cada centro de
processamento de dados.

Os experimentos emularam uma WAN pelo uso do
netem\footnote{\url{http://www.linuxfoundation.org/collaborate/workgroups/networking/netem}},
controlado pelo traffic control (tc). Ele provê funcionalidade para emulação de
características de rede como latência de rede e perda de pacotes. As
configurações de rede foram alteradas nos experimentos de acordo com
recomendações sobre otimizações de sistemas Linux para quando esses se comunicam
por WANs \cite{ESNet2012}. Um exemplo de otimização é usar o dobro do BDP como
tamanho dos buffers de transmissão e recepção.

Os experimentos foram executados no
Grid'5000\footnote{\url{http://www.grid5000.fr/}}, uma plataforma para criação,
execução e monitoramento de experimentos de sistemas paralelos e distribuídos.

O trabalho usou experimentos fatoriais, que consistem da combinação de dois ou
mais fatores em cada experimento que compõe o estudo \cite{Jain1991}. Quanto
maior a quantidade de fatores e níveis em um estudo, mais recursos são
necessários para sua execução. Por outro lado, alguns poucos fatores costumam
explicar a maior parte dos efeitos na resposta. Por isso, uma seleção de fatores
foi realizada pelo uso de experimentos 2\textsuperscript{k} com o objetivo de
identificar quais deles eram os mais influentes. Esse tipo de experimento é
realizado com apenas 2 níveis para cada fator, com um total de
2\textsuperscript{k} experimentos, onde k é a quantidade de fatores.

A seção seguinte mostra quais foram os parâmetros inicialmente fixados.

%% ------------------------------------------------------------------------- %%
\section{Parâmetros Fixados}

Foram levantados 33 parâmetros, dos quais 16 foram fixados por limitação de
recursos ou por não serem foco do estudo. Esses parâmetros e seus respectivos
valores são:

\begin{itemize}

\item \textbf{Aglomerado:} Os experimentos usaram o aglomerado \emph{sol} no
Grid'5000. Os nós desse aglomerado possuem CPU AMD Opteron 2218 2.6 GHz, 4 GB de
memória e placa de rede de 1 Gb/s.

\item \textbf{Mecanismo de armazenamento:} Ao usar memória como mecanismo de
armazenamento evitou-se ter que considerar os efeitos de disco, cache de disco e
sua interação com a quantidade de memória disponível, portanto os únicos efeitos
de E/S observados foram devidos à rede.

\item \textbf{Capacidade dos centros de processamento de dados:} Os centros de
processamento de dados tinham a mesma capacidade, com a mesma quantidade de nós
e os nós têm a mesma configuração de hardware.

\item \textbf{Algoritmo de particionamento das chaves:} O algoritmo padrão do
Riak foi usado (espalhamento consistente).

\item \textbf{Fator de replicação ($N$):} 3 é o valor que resulta em um balanço
razoável entre desempenho, disponibilidade e durabilidade em aplicações reais
\cite{DeCandia2007}.

\item \textbf{Limiar de migração (para consistência na linha do tempo):} 3, que
é o valor padrão do PNUTS \cite{Cooper2008}.

\item \textbf{Interface de acesso:} HTTP, por simplicidade de uso.

\item \textbf{Nível de log:} WARN, já que experimentos exploratórios mostraram
perda de desempenho quando o nível de log estava em INFO.

\item \textbf{Configuração de hardware dos dispositivos de rede intermediários:}
O único dispositivo de rede era um comutador FastIron Super X. Testes mostraram
que não existiam gargalos no comutador mesmo nos experimentos com maior consumo
de banda.

\item \textbf{Topologia da rede:} Estrela, que era a topologia do aglomerado.

\item \textbf{Largura de banda da LAN:} 1 Gb/s, a largura de banda das placas de
rede dos nós do aglomerado.

\item \textbf{Latência da LAN:} 167 $\mu$s, latência do aglomerado, medida com
ping com 60 amostras espaçadas em 5 s.
% ping -i 5 -c 60 sol-20

\item \textbf{Variação de latência da LAN:} 90 $\mu$s, variação de latência do
aglomerado, medida como acima.

\item \textbf{Largura de banda da WAN:} 100 Mb/s, baseado em estudo informal
citando que essa largura de banda é comumente observada entre zonas de
disponibilidade do AWS \cite{Pujol2012}.

\item \textbf{Quantidade de enlaces de WAN:} 1, o que resulta em dois centros de
processamento de dados usados nos experimentos.

\item \textbf{Taxa de chegada de requisições:} 15 operações/s para cada thread
de cada instância do \emph{benchmark}.

\end{itemize}

Com isso, ainda restavam 17 candidatos a fatores. Desses, três constituíam o
modo.

%% ------------------------------------------------------------------------- %%
\section{Fator Modo} \label{sec:modo}

Três fatores receberam um tratamento diferente ao longo do experimento: modelo
de consistência, configuração de replicação (para consistência em momento
indeterminado) e versão requisitada nas leituras (para consistência na linha do
tempo). Isso foi feito pois as combinações entre esses fatores definem
configurações do sistema de armazenamento que resultam em proporções de
requisições locais e remotas diferentes. Assim, esses fatores foram tratados
como um único fator chamado modo. Os modos adotados foram:

\begin{itemize}

\item \emph{ind1}: Consistência em momento indeterminado com $W$ = 1 e $R$ = 1

\item \emph{ind2}: Consistência em momento indeterminado com $W$ = 2 e $R$ = 1

\item \emph{lt\_qqer}: Consistência na linha do tempo com leituras de qualquer
versão

\item \emph{lt\_rec}: Consistência na linha do tempo com leituras da versão mais
recente

\end{itemize}

Considerando que o fator de replicação foi fixado como 3 e havia ao menos uma
réplica em cada centro de processamento de dados, duas situações eram possíveis
com relação à localização das réplicas: uma local e duas remotas ou vice-versa.
Dado isso, o modo \emph{ind1} resultava em leituras e escritas locais. O modo
\emph{ind2} resultava em leituras locais e metade das escritas local e a outra
metade remota. O modo \emph{lt\_qqer} resultava em leituras locais e a
quantidade de escritas dependente da localidade dos acessos. Finalmente, o modo
\emph{lt\_rec} resultava tanto em leituras quanto escritas dependentes da
localidade.

Esses modos implicam em trocas além de desempenho e consistência. A principal é
durabilidade, que para \emph{ind2} é mais alta do que para os outros casos, em
que a confirmação de escrita de uma única réplica é suficiente.

Ainda restavam 14 candidatos a fatores, quantidade grande para o estudo final.
Para reduzir essa quantidade, uma triagem de fatores com experimentos
2\textsuperscript{k} foi realizada.

%% ------------------------------------------------------------------------- %%
\section{Triagem dos Fatores} \label{sec:triagem_dos_fatores}

Uma abordagem para a seleção dos fatores seria agrupar todos os candidatos a
fatores em um único projeto de experimentos 2\textsuperscript{k}. O problema é
que mesmo com apenas dois níveis por fator, a quantidade final de experimentos
seria proibitiva.

A opção adotada então foi dividi-los em grupos menores e realizar experimentos
para cada grupo. O problema dessa separação é o fato de se perder a comparação
da influência de fatores de grupos diferentes. Por exemplo, localidade e
quantidade de nós de sistema foram tratados em estudos diferentes e cada um
apareceu como o fator mais influente do estudo de que fez parte. Como eles não
fizeram parte do mesmo estudo, a informação de qual deles é o mais influente foi
perdida, bem como a informação sobre a influência da interação entre eles. Se um
fosse muito mais influente do que o outro e a interação entre eles fosse baixa,
a decisão de fixar o menos influente não teria consequências. Mas sem essa
informação, fixar um deles representava ameaça à validade do estudo.

A maioria desses fatores era suscetível a interações com fatores de rede, como o
tamanho dos objetos armazenados, por exemplo. A latência de rede em particular
havia se mostrado muito influente em estudos exploratórios, fato confirmado
posteriormente pelo estudo para fatores de rede. Dado isso, a abordagem adotada
foi usar a latência como um representante da rede quando necessário.

Existiram casos onde as respostas de todos os experimentos de um estudo eram
semelhantes, independentemente dos níveis. Para tratar esses casos, também foram
calculados os coeficientes de variação\footnote{O coeficiente de variação é a
divisão do desvio padrão pela média e é uma maneira de representar a
variabilidade dos dados desconsiderando sua ordem de grandeza.} (CVs) das
respostas para estimar qual a influência daquele conjunto de fatores e
interações como um todo. Assim, um CV baixo indicava que nenhum dos fatores em
questão eram influentes.

Foi necessária uma etapa de aquecimento do sistema após a carga dos dados. Como
localidade era um fator, apenas a inserção de objetos na etapa de carga não era
suficiente para que o sistema operasse no seu estado estacionário durante os
experimentos para a consistência na linha do tempo. Isso porque, ao final da
carga, cada objeto no banco de dados tinha recebido apenas um acesso de cada
centro de processamento de dados, nenhuma réplica mestre teria migrado por
efeito da localidade até esse momento.

Foram realizados 4 estudos intermediários, descritos nas subseções seguintes.
Sempre que modo e localidade precisaram ser fixados, eles o foram
respectivamente em \emph{lt\_rec} e 50\%, valores que resultam em uma quantidade
balanceada de leituras e escritas locais e remotas. A latência, quando
necessária, foi fixada em 100 ms. Nos resultados, os percentis 10 e 90
representam respectivamente requisições locais e remotas. 

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de tamanho do sistema e \emph{benchmark}}
\label{sec:fatores_de_tamanho_do_sistema_e_benchmark}

As quantidades de nós de sistema e de instâncias do \emph{benchmark} não só
influenciavam as respostas, como também afetavam questões operacionais ligadas a
reserva de nós no Grid'5000. Portanto, um estudo foi feito para definir a
influência desses fatores. Os níveis selecionados foram (entre parênteses está o
identificador do fator na
Tabela~\ref{tab:estudo_para_quantidade_de_nos_do_sistema}):

\begin{itemize}

\item Quantidade de nós do sistema (N): 8 e 16

\item Quantidade de instâncias do \emph{benchmark} (B): 2 e 4

\item Quantidade de threads em cada instância do \emph{benchmark} (T): 32 e 64

\end{itemize}

O resultado do estudo está na Tabela
\ref{tab:estudo_para_quantidade_de_nos_do_sistema}.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline

Operação & Percentil & N & B & T & NB & NT & BT & NBT\\ \hline

leitura & 10 & 30 & 18 & 22 & 10 & 8 & 7 & 4 \\ \hline

leitura & 90 & 65 & 13 & 15 & 3 & 4 & 0 & 0 \\ \hline

escrita & 10 & 96 & 2 & 1 & 0 & 0 & 0 & 0 \\ \hline

escrita & 90 & 65 & 15 & 13 & 3 & 3 & 0 & 0 \\ \hline

\end{tabular} \caption{Estudo para tamanho do sistema.}
\label{tab:estudo_para_quantidade_de_nos_do_sistema} \end{table}

O tamanho do sistema teve a maior influência nos resultados e a quantidade de
instâncias do \emph{benchmark} e a quantidade de threads não são desprezíveis,
ainda mais ao se considerar as interações entre elas. Apesar disso, esses
fatores foram desconsiderados devido ao excesso de fatores. Dessa forma, os
valores fixados foram:

\begin{itemize}

\item Quantidade de nós do sistema: 16

\item Quantidade de instâncias do \emph{benchmark}: 4

\item Quantidade de threads em cada instância do \emph{benchmark}: 32

\end{itemize}

Esses valores foram selecionados pois resultaram em uma configuração ``leve'',
evitando gargalos de rede e não sobrecarregando o sistema. Ao mesmo tempo, a
quantidade total de nós necessária para os experimentos se enquadrava nas
limitações de recursos do aglomerado.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de banco de dados} \label{sec:fatores_de_banco_de_dados}

Um estudo foi feito para dimensionar o tamanho do banco de dados, que afetava o
uso de memória e de banda. Os níveis selecionados foram (entre parênteses está o
identificador do fator na
Tabela~\ref{tab:estudo_para_quantidade_e_tamanho_dos_objetos_armazenados} e L é
a latência):

\begin{itemize}

\item Quantidade de objetos armazenados (Q): 64.000 e 256.000

\item Tamanho dos objetos armazenados (T): 100 e 10.000 bytes

\end{itemize}

O resultado do estudo está na Tabela
\ref{tab:estudo_para_quantidade_e_tamanho_dos_objetos_armazenados}.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline

Operação & Percentil & Q & T & L & QT & QL & TL & QTL\\ \hline

leitura & 10 & 0 & 100 & 0 & 0 & 0 & 0 & 0 \\ \hline

leitura & 90 & 0 & 0 & 100 & 0 & 0 & 0 & 0 \\ \hline

escrita & 10 & 0 & 100 & 0 & 0 & 0 & 0 & 0 \\ \hline

escrita & 90 & 0 & 0 & 100 & 0 & 0 & 0 & 0 \\ \hline

\end{tabular} \caption{Estudo para quantidade e tamanho dos objetos
armazenados.}
\label{tab:estudo_para_quantidade_e_tamanho_dos_objetos_armazenados} \end{table}

A quantidade de objetos não afetou o desempenho do sistema. O tamanho dos
objetos não afetou o desempenho das requisições remotas, mas com relação às
requisições locais apareceu com 100\% de influência. Apesar disso, o CV das
requisições locais indicava que sua influência não era tão grande -- 19\% para
leituras e 16\% para escritas. Assim, os valores fixados foram:

\begin{itemize}

\item Quantidade de objetos armazenados: 128.000

\item Tamanho dos objetos armazenados (bytes): 500

\end{itemize}

O tempo de aquecimento dependia da quantidade de objetos armazenados, portanto
quanto menor essa quantidade, mais rápida era a execução dos experimentos. Por
outro lado, um número muito pequeno resultaria em excesso de conflitos. No caso
do tamanho dos objetos armazenados, o valor foi escolhido baseado em estudo dos
sistemas de caching no Facebook, que relata que 90\% dos objetos são menores do
que 500 bytes \cite{Atikoglu2012}.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de rede} \label{sec:fatores_de_rede}

Dado o objetivo do trabalho, o estudo para fatores de rede era um dos mais
importantes da etapa de seleção de fatores. Os níveis inicialmente selecionados
foram (entre parênteses está o identificador do fator na
Tabela~\ref{tab:estudo_para_fatores_de_rede}):

\begin{itemize}

\item Latência da WAN (L): 100 e 300 ms

\item Variação da latência da WAN (V): 1 e 60\%

\item Taxa de perda de pacotes na WAN (P): 0,01 e 0,3\%

\item Taxa de duplicação de pacotes na WAN (D): 0,05 e 5\%

\item Taxa de reordenação de pacotes na WAN (O): 0,05 e 5\%

\item Variação de TCP (T): CUBIC e H-TCP

\end{itemize}

Os níveis da latências foram baseados em um estudo que relata as latências entre
as regões do AWS \cite{Sovran2011}. A menor latência observada foi 82 ms entre
os centros de processamento de dados dos EUA e a maior foi 277 ms entre Irlanda
e Singapura.
 
Tanto H-TCP quanto CUBIC foram projetados com foco em redes com largura de banda
e latências grandes (BDP alto) e foram escolhidos pois são citados nas
referências sobre otimizações da pilha TCP para WANs \cite{ESNet2012}.

O projeto PingER\footnote{\emph{Ping End-to-end Reporting} (Relatório de Ping
Fim-a-fim) monitora o desempenho fim-a-fim de enlaces de Internet.} serviu de
base para os outros fatores\cite{Pinger2013}.  Ele mostra em janeiro de 2013 uma
média de latência de 238,062 ms com desvio padrão de 142,996, o que resulta em
uma variação de 60\%. Os 11 meses anteriores apresentavam valores semelhantes. A
mediana da taxa de perda de pacotes do último ano foi 0,178\%. A taxa de
duplicação de pacotes é muito baixa, em janeiro de 2013 a média foi 0,006\% e a
mediana foi 0\%. Os valores usados no experimento para duplicação e reordenação
foram bem maiores do que os observados pelo PingER, mas mesmo assim não
influenciaram a resposta (ver abaixo).

No emulador de rede, a latência define o mínimo e a variação o máximo a que ela
pode chegar. Por exemplo, ao fazer a configuração de 100 ms de latência e 60\%
de variação, o emulador gera valores entre 100 ms e 160 ms. Os valores gerados
obedeciam a distribuição normal dentro da faixa de latência especificada.

O resultado do estudo está na Tabela \ref{tab:estudo_para_fatores_de_rede}. Com
exceção dos fatores e da interação entre latência e variação de latência, todas
as outras colunas apresentavam valores nulos e foram suprimidas. As respostas
das requisições locais apresentaram CVs de 1\%, portanto as respectivas linhas
também foram suprimidas.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline

Operação & Percentil & L & V & P & D & O & T & LV\\ \hline

leitura & 90 & 72 & 21 & 1 & 0 & 0 & 0 & 6\\ \hline

escrita & 90 & 69 & 23 & 1 & 0 & 0 & 0 & 6\\ \hline

\end{tabular}

\caption{Estudo para fatores de rede. A soma para escritas não é 100\% devido a
arredondamento.} \label{tab:estudo_para_fatores_de_rede}

\end{table}

A latência, a variação de latência e a interação de primeira ordem entre elas
responderam por 100\% dos resultados. Assim, os níveis escolhidos para esses
fatores nos experimentos foram:

\begin{itemize} \item Latência da WAN (ms): 0, 100, 200 e 300

\item Variação da latência da WAN (\%): 0 e 60

\end{itemize}

Níveis nulos de latência e variação da latência equivalem a ter todo o sistema
operando em uma rede local. Os resultados obtidos para esses casos foram usados
como auxílio na interpretação dos resultados, mas não foram considerados no
estudo final.

Os valores fixados dos fatores desconsiderados foram:

\begin{itemize}

\item Taxa de perda de pacotes na WAN (\%): 0

\item Taxa de duplicação de pacotes na WAN (\%): 0

\item Taxa de reordenação de pacotes na WAN (\%): 0

\item Algoritmo de congestionamento: CUBIC

\end{itemize}

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de carga de trabalho}
\label{sec:fatores_de_carga_de_trabalho}

Este era um dos estudos mais importantes juntamente ao estudo para fatores de
rede. Os níveis selecionados foram (entre parênteses está o identificador do
fator na Tabela~\ref{tab:estudo_para_fatores_de_carga_de_trabalho}):

\begin{itemize}

\item Relação leitura/escrita (R): 2:1 e 10:1

\item Popularidade dos objetos (P): uniforme (a taxa de chegada de requisições
média para cada objeto é a mesma) e concentrada (a taxa de chegada segue uma
distribuição Pareto)

\item Localidade (X): 50\% (sem localidade) e 90\% (90\% dos acessos para
determinado objeto vindo de um centro de processamento de dados e 10\% do outro)

\end{itemize}

Como os modos possuem comportamentos diferentes para requisições locais e
remotas, os experimentos foram executados para cada modo. O resultado para
requisições locais apresentaram CVs em torno de 0,02 para todos os modos. Isso
indica que requisições locais não sofrem influência de nenhum dos fatores. Já
requisições remotas apresentaram CVs de aproximadamente 50\% e influência da
latência de 100\% para \emph{ind2}, \emph{lt\_qqer} e \emph{lt\_rec}
(\emph{ind1} não tem requisições remotas).

A análise da relação leitura/escrita e localidade não usou percentis, mas sim a
média do tempo de resposta de todas as requisições (leituras e escritas). Isso
porque o primeiro fator diz respeito à composição entre leituras e escritas e o
segundo altera a composição entre requisições locais e remotas, portanto esses
fatores não fazem sentido nos percentis separados por tipo de requisição. Por
exemplo, com localidade de 50\% percebe-se que o percentil 70 representa
requisições remotas, enquanto com localidade de 90\% o mesmo percentil
representa requisições locais. Se a análise fosse feita por percentis, essa
informação se perderia e localidade nunca teria influência. O resultado do
estudo está na Tabela \ref{tab:estudo_para_fatores_de_carga_de_trabalho}
(colunas com todas as células menores do que 5\% foram removidas).

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|} \hline

Modo & R & X & P & L & RX & RL & XL & PL & XPL\\ \hline

\emph{ind1} & 19 & 12 & 2 & 31 & 0 & 2 & 6 & 6 & 8\\ \hline

\emph{ind2} & 50 & 0 & 0 & 39 & 0 & 11 & 0 & 0 & 0\\ \hline

\emph{lt\_qqer} & 25 & 30 & 0 & 19 & 9 & 6 & 8 & 0 & 0\\ \hline

\emph{lt\_rec} & 0 & 53 & 0 & 34 & 0 & 0 & 13 & 0 & 0\\ \hline

\end{tabular} \caption{Estudo para fatores de carga de trabalho.}
\label{tab:estudo_para_fatores_de_carga_de_trabalho}

\end{table}

Como esperado, localidade e latência influenciaram as respostas em geral. O
impacto de popularidade dos objetos é praticamente nulo. Apesar de alguns modos
aparentemente terem sido impactados pela relação leitura/escrita, esse impacto
foi consequência da relação entre requisições locais e remotas. Para
\emph{ind1}, tanto leituras quanto escritas são locais e a relação
leitura/escrita e suas interações com outros fatores impacta pouco esse modo.
Para \emph{lt\_rec}, leituras e escritas são locais ou remotas dependendo da
localidade e a relação leitura/escrita não impacta esse modo. Para \emph{ind2},
todas as leituras são locais e metade das escritas é remota, portanto quando a
relação leitura/escrita muda, a relação entre requisições locais e remotas muda
proporcionalmente -- como esperado, esse modo é impactado pela relação
leitura/escrita. A mesma observação vale para \emph{lt\_qqer}, que tem todas as
leituras locais e escritas dependendo da localidade, e também sofre impacto da
relação leitura/escrita. Caso o mecanismo de armazenamento fosse disco em vez de
memória, a relação leitura/escrita provavelmente sofreria impacto. Isso porque
escritas seriam afetadas pelo tempo de escrita no disco, enquanto leituras
poderiam ser mais rápidas pois parte delas seriam servidas a partir do cache de
disco.

Dessa forma, só foram escolhidos níveis para localidade:

\begin{itemize}

\item Localidade (\%): 50 e 90

\end{itemize}

Os valores fixados dos fatores desconsiderados foram:

\begin{itemize}

\item Relação leitura/escrita: 2:1

\item Popularidade dos objetos: uniforme

\end{itemize}

%% ------------------------------------------------------------------------- %%
\section{Análise dos Resultados}

O estudo final consistiu de um total de 64 experimentos, com os fatores
selecionados nos estudos 2\textsuperscript{k}, apresentados na
Tabela~\ref{tab:fatores_e_niveis_do_estudo_final}.

\begin{table}[ht] \centering \begin{tabular}{|l|c|c|} \hline

\multicolumn{1}{|c|}{Fator} & \multicolumn{1}{|c|}{Níveis} &
\multicolumn{1}{|c|}{Total de níveis}\\ \hline

Modo & \emph{ind1}, \emph{ind2}, \emph{lt\_qqer} e \emph{lt\_rec} & 4\\ \hline

Latência da WAN (ms) & 0, 100, 200 e 300 & 4\\ \hline

Variação da latência da WAN (\%) & 0 e 60 & 2\\ \hline

Localidade & 50\% e 90\% & 2\\ \hline

\end{tabular}

\caption{Fatores e níveis do estudo final.}
\label{tab:fatores_e_niveis_do_estudo_final}

\end{table}

%% ------------------------------------------------------------------------- %%
\subsection{Amostras e Replicações}

Os experimentos usaram uma quantidade de amostras tal que o nível de confiança
fosse 99\% e a exatidão fosse 1\% \cite{Jain1991}. O único caso com um número de
amostra menor que o necessário foi \emph{lt\_rec} -- nesse caso, o mesmo nível de
confiança foi adotado e a exatidão foi 2\%.

Uma replicação do estudo foi feita para estimar a variabilidade dos
experimentos. Isso foi feito calculando-se os CVs de duas replicações de cada
experimento. A média dos CVs de todos os experimentos foi 1\% para leituras e
0,8\% para escritas, e o máximo foi 8\% para leituras e 5\% para escritas.

%% ------------------------------------------------------------------------- %%
\subsection{Análise dos Tempos de Resposta}
\label{sec:analise_dos_tempos_de_resposta}

Os resultados para latências de 100 ms, 200 ms e 300 ms apresentam o mesmo
comportamento, portanto a opção foi fazer a análise para um deles apenas. O
\emph{boxplot} para latência de rede de 200~ms está na Figura
\ref{fig:boxplot_dos_tempos_de_resposta_para_latencia_de_rede_de_200_ms}. Os
casos em que a caixa não aparece indicam que todas as requisições delimitadas
pelos bigodes eram locais.

\begin{figure}[ht] \centering

\includegraphics[width=1\textwidth]{boxplot200.png}

\caption{\emph{Boxplot} dos tempos de resposta para latência de rede de 200 ms.}
\label{fig:boxplot_dos_tempos_de_resposta_para_latencia_de_rede_de_200_ms}
\end{figure}

No caso de leituras e localidade de 50\%, apenas \emph{lt\_rec} apresenta
requisições remotas. Uma porção pequena dessas leituras tem tempo de resposta
menor que a latência da rede, o que se explica pelo \emph{jitter} de até 60\%.

Para leituras e localidade de 90\%, \emph{lt\_rec} é beneficiado, mas continua
apresentando requisições remotas (valores atípicos no gráfico).  No caso de
escritas e localidade de 50\%, \emph{lt\_rec} apresenta um desempenho um pouco
melhor que \emph{ind2} e \emph{lt\_qqer}. A explicação provável para isso é o
sistema estar menos carregado para esse modo do que os outros, o que acontece
pois as leituras de \emph{lt\_rec} são mais lentas. Esse fato é comprovado pela
vazão dos modos \emph{lt\_rec}, ev2 e \emph{lt\_qqer}, respectivamente, 594,
1072, 941 operações/s.

Para escritas e localidade de 90\%, \emph{lt\_rec} e \emph{lt\_qqer} apresentam
melhor desempenho devido à localidade, mas ainda apresentam requisições remotas
(valores atípicos no gráfico). Já \emph{ind2} continua apresentando o mesmo
perfil que para localidade de 50\%.

Os modos apresentaram o comportamento esperado. A hipótese de que a consistência
na linha do tempo é competitiva em termos de desempenho com a consistência em
momento indeterminado se confirma para o caso em que a localidade é alta e
principalmente caso leituras de ``qualquer versão'' sejam usadas.

%% ------------------------------------------------------------------------- %%
\subsection{Ameaças à Validade} \label{sec:ameacas_a_validade}

Muitos parâmetros foram fixados e fatores tidos como influentes foram
desconsiderados. Com isso, estudos
que usem outros valores para os parâmetros ou considerem outros fatores podem
apresentar resultados diferentes. Isso vale particularmente para a quantidade de nós do
sistema, que apareceu com influência relativamente alta. Além disso, outras
faixas de níveis podem levar a outros resultados \cite{Jain1991}.

Os experimentos consideram que todos os nós sempre operam sem falhas. Os resultados de experimentos com o sistema
operando em algum modo de falha (desde a falha de um nó até de um centro de
processamento de dados inteiro) devem ser diferentes dos obtidos nesse estudo.
Observação semelhante vale para a carga do sistema.

%% ------------------------------------------------------------------------- %%
\section{Trabalhos Relacionados} \label{sec:trabalhos_relacionados}

Uma abordagem comum na literatura de sistemas distribuídos é a proposta de um
novo conceito e a implementação de um sistema que use esse conceito seguida de
uma análise de seu desempenho. Tanto o artigo sobre o Dynamo \cite{DeCandia2007}
quanto o sobre o PNUTS \cite{Cooper2008} apresentam análises de desempenho,
sendo que apenas o segundo faz uma análise baseada na carga de trabalho. Há uma
segunda publicação com experimentos com o PNUTS que analisa o consumo de banda
de diferentes políticas de replicação em uma WAN \cite{Kadambi2011}.

Muitos trabalhos apresentam análises de desempenho de sistemas de armazenamento
que usam replicação sobre WANs. Na maior parte dos casos, o objetivo desses
sistemas é provar outros conceitos além da eficiência do modelo de consistência
escolhido por eles. O COPS usa consistência causal+, que é semelhante à
consistência causal com algumas garantia a mais, e implementa transações
\cite{Lloyd2011}. O Scatter propõe uma arquitetura ao mesmo tempo escalável e
com consistência forte \cite{Glendenning2011}. O Windows Azure
provê um sistema de armazenamento na nuvem com consistência forte
\cite{Calder2011}. O Megastore usa Paxos para implementar consistência forte
\cite{Baker2011}. Nenhum desses trabalhos apresenta comparações com outros
sistemas ou com outros modelos de consistência. Como eles não usam uma aplicação
para execução de testes ou ambiente comum, é difícil fazer qualquer comparação a
partir desses trabalhos.

Beyer et al. realizaram testes para analisar a relação entre as diferentes
configurações de consistência no Cassandra e sua disponibilidade e desempenho
\cite{Beyer2011}. Como esperado, eles notam que configurações que oferecem
consistência mais rígida apresentam pior desempenho. Renesse e Schneider
apresentam resultados experimentais comparando desempenho e disponibilidade de
replicação mestre-escravo e replicação em cadeia, cada uma delas usando
consistência forte e consistência em momento indeterminado
\cite{VanRenesse2004}. Nenhum desses dois experimentos leva em consideração
operação sobre WAN nem diferentes cargas de trabalho.

Uma publicação com uma proposta mais próxima da deste trabalho é a comparação
feita entre Cassandra, HBase, PNUTS e MySQL particionado horizontalmente usando
diferentes cargas de trabalho \cite{Cooper2010}. Os resultados servem como uma
comparação entre esses sistemas, mas dizem menos sobre seus modelos de
consistência, dado que os sistemas apresentam arquiteturas e configurações
diferentes. Além disso, os testes são feitos em uma rede local, não em uma WAN.

%% ------------------------------------------------------------------------- %%
\section{Conclusões}

Este trabalho comparou o desempenho de um mesmo sistema de armazenamento usando
dois modelos de consistência diferentes operando
em uma WAN. Além disso, apresentou resultados sobre a
infuência que diversos fatores têm sobre o desempenho de um sistema de
armazenamento operando sobre WAN. A consistência na linha do tempo se mostrou competitiva com a
consistência em momento indeterminado quando a localidade de escritas é alta e
quando as leituras são de ``qualquer versão''.

As principais vantagens da consistência na linha do tempo sobre em momento
indeterminado são a garantia de que as réplicas não são atualizadas com valores
divergentes e a existência de uma réplica mestre que corresponde à versão mais
recente. Um cenário
interessante para seu uso é o
caso em que a aplicação tolera inconsistências na maioria das leituras, mas em
algumas poucas situações precisa da versão consistente. Já sua principal desvantagem é a indisponibilidade da réplica mestre impedir escritas e leituras
consistentes. Outra desvantagem é que mesmo sendo competitiva, ela apresenta
variabilidade relativamente alta nos tempos de resposta. Para
aplicações em que os requisitos de tempos de resposta são dados pelo percentil
99,9, como é o caso da Amazon \cite{DeCandia2007}, a consistência na linha do
tempo não é adequada.

%% ------------------------------------------------------------------------- %%
\section{Agradecimentos}

Os experimentos apresentados neste trabalho foram realizados utilizando a
plataforma para experimentos Grid'5000, desenvolvida pela ação de
desenvolvimento ALADDIN INRIA com o apoio do CNRS, RENATER e várias
universidades, bem como outros organismos de financiamento (ver
\url{https://www.grid5000.fr}).

% \begin{table}[ht] \centering \caption{Variables to be considered on the
% evaluation of interaction techniques} \label{tab:exTable1}
% \includegraphics[width=.7\textwidth]{table.jpg} \end{table}

\section{Referências} \bibliographystyle{sbc} \bibliography{bibliografia}

\end{document}
