\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

\usepackage[brazil]{babel}   

\usepackage[latin1]{inputenc}  

\graphicspath{{./figuras/}}
     
\sloppy

\hyphenation{re-la-xa-do re-pre-sen-ta Facebook Yahoo re-qui-si-tos
ex-pe-ri-men-tal}

\title{Desempenho de Sistemas com Dados Georeplicados\\ com Consistência em
Momento Indeterminado e\\ na Linha do Tempo}

\author{Mauricio De Diana\inst{1}, Marco Aurélio Gerosa\inst{1}}

\address{Instituto de Matemática e Estatística -- Universidade de São Paulo
(USP)\\ \email{\{mdediana,gerosa\}@ime.usp.br}}

\begin{document} 

\maketitle

\begin{abstract}

Large-scale web systems replicate data among data centers to achieve high levels
of performance and availability. A consistency model defines the tradeoffs
between these requirements and replica consistency. This work compared
experimentally the performace of a storage system using eventual consistency and
timeline consistency. The results show that, depending on the workload and the
network conditions, system performances for each consistency model are similar.
This comparative is helpful for development cost estimates and capacity planning
of large-scale web systems.

\end{abstract}
     
\begin{resumo}

Sistemas web de larga escala replicam dados entre centros de dados para atingir
altos níveis de desempenho e disponibilidade. Um modelo de consistência define o
balanço entre esses requisitos e a consistência dos dados entre réplicas. Este
trabalho comparou experimentalmente o desempenho de um sistema de armazenamento
georeplicado usando consistência em momento indeterminado e consistência na
linha do tempo. Os resultados mostram que, dependendo da carga de trabalho e das
condições de rede, os desempenhos do sistema para cada um dos modelos de
consistência são semelhantes. Essa comparação é útil em estimativas de custo de
desenvolvimento e de planejamento de capacidade de sistemas web de larga escala.

\end{resumo}

%% ------------------------------------------------------------------------- %%
\section{Introdução} \label{sec:introducao}

Para atender centenas de milhares de usuários ininterruptamente em sistemas web
de larga escala, dados são replicados em milhares de servidores distribuídos em
múltiplos centros de processamento de dados em diferentes localizações
geográficas. O principal problema do uso de replicação em redes de longa
distância (WANs) é que manter as réplicas sempre consistentes entre si
tipicamente implica em sacrificar outros requisitos também importantes, como
desempenho ou disponibilidade. Um motivo para divergência entre réplicas é que a
replicação entre centros de processamento de dados pode apresentar centenas de
milissegundos de latência, período durante o qual as réplicas podem divergir.
Essa latência é resultado não só das distâncias físicas entre os nós, mas também
de limitações na largura de banda disponível e congestionamento de rede.  Outro
motivo de divergência entre réplicas é a falha temporária de um nó, que deixa de
receber atualizações por um período de tempo. Um terceiro motivo é o
particionamento de rede, causado por exemplo por uma falha em um equipamento ou
enlace de rede que impeça a comunicação entre réplicas.

Nesse cenário, desenvolvedores e administradores de sistemas web de larga escala
buscam um balanço entre disponibilidade, desempenho e consistência dos dados.
Uma decisão comum em vários desses sistemas é o relaxamento da consistência em
troca de alta disponibilidade e baixa latência. Entretanto, modelos de
consistência mais relaxados permitem que conflitos entre réplicas aconteçam, o
que torna o código da aplicação mais complexo devido a necessidade de
implementação de mecanismos de resolução de conflitos e ações de compensação.

Este trabalho é um comparativo de desempenho de um sistema de armazenamento
georeplicado usando dois modelos de consistência diferentes. Um deles, a
consistência em momento indeterminado (\textit{eventual consistency}\footnote{O
termo \textit{eventual consistency} não foi traduzido como \textit{consistência
eventual} pois \textit{eventual} é um falso cognato: em inglês indica que algo
certamente acontecerá no futuro, enquanto em português indica que algo pode ou
não vir a acontecer.}) é um modelo mais relaxado e se tornou especialmente
popular após a publicação sobre o Dynamo da Amazon \cite{DeCandia2007}. Um
modelo de consistência para sistemas georeplicados menos popular, que busca um
meio termo entre consistência forte e consistência em momento indeterminado é a
consistência na linha do tempo, usada no PNUTS do Yahoo! \cite{Cooper2008}. Ela
é uma opção interessante por simplificar a programação, desde que seu desempenho
seja próximo ao da consistência em momento indeterminado e a aplicação tolere
níveis mais baixos de disponibilidade.

%% ------------------------------------------------------------------------- %%
\section{Consistência em Momento Indeterminado e na Linha do Tempo}
\label{sec:consistencia_em_momento_indeterminado_e_na_linha_do_tempo}

A consistência em momento indeterminado garante que as réplicas vão sempre
convergir em algum momento no futuro desde que novas atualizações cessem.
Enquanto atualizações estiverem acontecendo, réplicas inconsistentes são
possíveis, e clientes podem acessar dados desatualizados ou divergentes -- por
isso o sistema precisa implementar algoritmos de detecção e resolução de
conflitos. Uma forma de diminuir as chances de conflitos é o uso de quóruns,
cujo contraponto é a diminuição da disponibilidade do sistema quando um
determinado quórum não é atingido \cite{Vogels2009}. Costuma-se usar os
parâmetros N, R e W para definir os quóruns. N é o fator de replicação e
representa a quantidade de réplicas existentes de um objeto. R/W é a quantidade
de réplicas que precisam concordar com o mesmo valor para que uma
leitura/escrita seja bem sucedida. Quando $N < R + W$, não existe possibilidade
de clientes lerem dados inconsistentes, dado que existe intersecção entre os
subconjuntos de réplicas para leitura e escrita.

Algumas aplicações web tornam-se mais simples com um modelo de consistência mais
rígido. Por exemplo, uma aplicação de leilão não pode permitir conflitos no
histórico de lances de um produto. Num sistema que usa consistência em momento
indeterminado, no caso de uma falha que divida a rede em duas partições,
usuários em cada partição têm uma visão própria do histórico de lances,
equivalente a dois leilões simultâneos sobre o mesmo item.

A consistência na linha do tempo abre mão de disponibilidade em algumas
situações em troca de consistência \cite{Cooper2008}. Para cada objeto
armazenado, ela permite atualizações em apenas uma de suas réplicas (réplica
mestre). Devido à replicação assíncrona, réplicas podem ter valores
desatualizados devido à latência de rede ou falhas, mas a qualquer instante
sabe-se qual é a réplica com o valor mais recente. Os clientes escolhem em cada
acesso se aceitam como resposta apenas o valor mais recente ou se aceitam
valores desatualizados. Além disso, como a réplica mestre define uma ordem de
aplicação de atualizações nas outras réplicas, divergências não acontecem e
mecanismos de detecção e resolução de conflitos não são necessários. A principal
desvantagem da consistência na linha do tempo é que a existência de uma réplica
mestre implica que escritas e leituras consistentes (leituras do valor mais
recente) ficam indisponíveis em caso de uma falha que impeça o acesso a essa
réplica.

O maior fator de impacto no desempenho da consistência na linha do tempo é o
fato de que operações consistentes que não são feitas no centro de processamento
de dados em que está a réplica mestre incorrem no custo de comunicação pela WAN.
Mas os autores do PNUTS indicam que algumas aplicações no Yahoo! apresentam
localidade de até 85\% e relação escrita/leitura de 0,06
\cite{Kadambi2011,Cooper2008}. Dado isso, eles implementaram uma heurística em
que a réplica mestre migra para o centro de processamento de dados que recebeu
as últimas 3 escritas. Dessa forma, em uma aplicação na qual a quantidade de
leituras é muito maior do que a quantidade de escritas, o custo de comunicação
de rede é baixo, em especial se as leituras não precisarem necessariamente do
valor mais recente.

%% ------------------------------------------------------------------------- %%
\section{Planejamento dos Experimentos}
\label{sec:planejamento_dos_experimentos}

Para entender o desempenho resultante de cada modelo de consistência, um estudo
experimental foi realizado. Seu planejamento e execução usaram \cite{Jain1991}
como principal referência metodológica.

Três técnicas são comumente usadas na análise de desempenho de sistemas:
simulação, modelagem analítica e medição \cite{Jain1991}. Como inicialmente 33
parâmetros foram considerados (ver seções seguintes), seria difícil evitar a
perda de precisão decorrente de simplificações necessárias para a criação de
simuladores ou modelos com tantos parâmetros. Portanto, medição foi a técnica
escolhida.

Um sistema precisava ser escolhido como objeto do estudo. Como nenhum sistema
com os dois modelos de consistência foi encontrado, optou-se por implementar a
consistência na linha do tempo no Riak, sistema de software livre que já traz
consistência em momento indeterminado \cite{Riak2013}. Além do novo modelo de
consistência, também foi implementado um algoritmo de particionamento que
garante que existe ao menos uma réplica de cada objeto em cada centro de
processamento de dados\footnote{Implementações disponíveis em
\url{https://github.com/mdediana/riak_kv} e
\url{https://github.com/mdediana/riak_core}}.

Como \textit{benchmark}, foi usado o Basho Bench, específico para Riak
\cite{BashoBench2013}. Ele foi adaptado para executar de forma distribuída, com
uma instância para cada centro de processamento de dados.

Os experimentos emularam uma WAN pelo uso do netem, controlado pelo traffic
control (tc). Ele provê funcionalidade para emulação de características de rede
como latência e perda de pacotes. As configurações de rede foram alteradas nos
experimentos de acordo com recomendações sobre otimizações de sistemas Linux
para quando esses se comunicam por WANs \cite{ESnet2012}, como usar o dobro do
Produto Banda-Atraso (BDP) como tamanho dos buffers de transmissão e recepção,
por exemplo.

Os experimentos foram executados no Grid'5000, uma plataforma para criação,
execução e monitoramento de experimentos de sistemas paralelos e distribuídos
\cite{Grid50002013}.

O trabalho usou experimentos fatoriais, que consistem da combinação de fatores
em cada experimento que compõe o estudo \cite{Jain1991}. Quanto maior a
quantidade de fatores e níveis em um estudo, mais recursos são necessários para
sua execução. Por outro lado, alguns poucos fatores costumam explicar a maior
parte dos efeitos na resposta. Por isso, uma seleção dos fatores mais influentes
foi realizada pelo uso de experimentos 2\textsuperscript{k}. Esse tipo de
experimento é realizado com apenas 2 níveis para cada fator, com um total de
2\textsuperscript{k} experimentos, onde k é a quantidade de fatores.

%% ------------------------------------------------------------------------- %%
\section{Parâmetros Fixados} \label{sec:parametros_fixados}

Após definido o tipo de estudo experimental, foram levantados 33 parâmetros, dos
quais 16 foram fixados por limitação de recursos ou por não serem foco do
estudo. Vale notar que os parâmetros de LAN referem-se aos disponíveis no
aglomerado, enquanto do de WAN foram emulados. Os parâmetros fixados e seus
respectivos valores foram:

\begin{itemize}

\item \textbf{Aglomerado:} Os experimentos usaram o aglomerado \textit{sol} no
Grid'5000. Os nós desse aglomerado possuem CPU AMD Opteron 2218 2.6 GHz, 4 GB de
memória e placa de rede de 1 Gb/s.

\item \textbf{Mecanismo de armazenamento:} Ao usar memória como mecanismo de
armazenamento evitou-se ter que considerar os efeitos de disco, cache de disco e
a interação entre cache de disco e quantidade de memória, portanto os únicos
efeitos de E/S observados foram devidos à rede.

\item \textbf{Capacidade dos centros de processamento de dados:} Os centros de
processamento de dados tinham a mesma capacidade -- mesma quantidade de nós por
centro e nós com a mesma configuração de hardware.

\item \textbf{Algoritmo de particionamento das chaves:} O algoritmo padrão do
Riak foi usado (espalhamento consistente).

\item \textbf{Fator de replicação ($N$):} 3 é o valor que resulta em um balanço
razoável entre desempenho, disponibilidade e durabilidade em aplicações reais
\cite{DeCandia2007}.

\item \textbf{Limiar de migração (para consistência na linha do tempo):} 3 é o
valor padrão do PNUTS \cite{Cooper2008}.

\item \textbf{Interface de acesso:} HTTP, por simplicidade de uso.

\item \textbf{Nível de log:} WARN, já que experimentos exploratórios mostraram
perda de desempenho quando o nível de log estava em INFO.

\item \textbf{Configuração de hardware dos dispositivos de rede intermediários:}
O único dispositivo de rede era um comutador FastIron Super X. Testes mostraram
que não existiam gargalos no comutador mesmo nos experimentos com maior consumo
de banda.

\item \textbf{Topologia da rede:} Estrela, a única topologia de rede disponível
no Grid'5000.

\item \textbf{Largura de banda da LAN:} 1 Gb/s era a largura de banda das placas
de rede dos nós do aglomerado.

\item \textbf{Latência da LAN:} 167 $\mu$s, latência do aglomerado, medida com
ping com 60 amostras espaçadas em 5 s.
% ping -i 5 -c 60 sol-20

\item \textbf{\textit{Jitter} da LAN:} 90 $\mu$s, \textit{jitter} do aglomerado
medido como a latência.

\item \textbf{Largura de banda da WAN:} 100 Mb/s, baseado em estudo informal
citando que essa largura de banda é comumente observada entre zonas de
disponibilidade do AWS \cite{Pujol2012}.

\item \textbf{Quantidade de enlaces de WAN:} 1, o que resulta em dois centros de
processamento de dados usados nos experimentos.

\item \textbf{Taxa de chegada de requisições:} 15 operações/s para cada thread
de cada instância do \textit{benchmark}.

\end{itemize}

Com isso, ainda restavam 17 candidatos a fatores. Desses, 3 constituíam o modo.

%% ------------------------------------------------------------------------- %%
\section{Fator Modo} \label{sec:modo}

Três fatores receberam um tratamento diferente ao longo do experimento: modelo
de consistência, configuração de replicação (para consistência em momento
indeterminado) e versão requisitada nas leituras (para consistência na linha do
tempo). Isso foi feito pois as combinações entre esses fatores definem
configurações do sistema de armazenamento que resultam em proporções de
requisições locais e remotas diferentes. Assim, esses fatores foram tratados
como um único fator chamado modo. Os modos adotados foram:

\begin{itemize}

\item \textit{ind1}: Consistência em momento indeterminado com $W$ = 1 e $R$ = 1

\item \textit{ind2}: Consistência em momento indeterminado com $W$ = 2 e $R$ = 1

\item \textit{lt\_qqer}: Consistência na linha do tempo com leituras de qualquer
versão

\item \textit{lt\_rec}: Consistência na linha do tempo com leituras da versão
mais recente

\end{itemize}

Considerando que o fator de replicação foi fixado em 3 e havia ao menos uma
réplica em cada centro de processamento de dados, duas situações eram possíveis
com relação à localização das réplicas de um objeto: uma local e duas remotas ou
vice-versa.  Dado isso, o modo \textit{ind1} resultava em leituras e escritas
locais. O modo \textit{ind2} resultava em leituras locais e metade das escritas
local e a outra metade remota. O modo \textit{lt\_qqer} resultava em leituras
locais e a quantidade de escritas dependente da localidade dos acessos.
Finalmente, o modo \textit{lt\_rec} resultava tanto em leituras quanto escritas
dependentes da localidade.

Esses modos implicam em trocas além de desempenho e consistência. A principal é
durabilidade, que para \textit{ind2} é mais alta do que para os outros casos, em
que a confirmação de escrita de uma única réplica é suficiente.

Ainda restavam 14 candidatos a fatores, quantidade grande para o estudo final.
Para reduzir essa quantidade, uma triagem de fatores com experimentos
2\textsuperscript{k} foi realizada.

%% ------------------------------------------------------------------------- %%
\section{Triagem dos Fatores} \label{sec:triagem_dos_fatores}

Uma abordagem para a seleção dos fatores seria agrupar todos os candidatos a
fatores em um único projeto de experimentos 2\textsuperscript{k}. O problema é
que mesmo com apenas dois níveis por fator, a quantidade final de experimentos
seria proibitiva.

A opção adotada então foi dividí-los em grupos menores de fatores relacionados e
realizar estudos para cada grupo. Com isso, perdeu-se a comparação entre fatores
de grupos diferentes e suas interações. Mas como a maioria dos fatores se
mostrou pouco influente em seus grupos, como se vê nas subseções a seguir, essa
abordagem não apresentou ameaça à validade.

A maioria dos fatores era suscetível a interações com fatores de rede. A
latência da WAN em particular havia se mostrado muito influente em estudos
exploratórios, fato confirmado posteriormente pelo estudo para fatores de rede.
Dado isso, a abordagem adotada foi usar latência como representante da WAN
quando necessário.

Existiram casos onde as respostas de todos os experimentos de um estudo eram
semelhantes, independentemente dos níveis. Para tratar esses casos, também foram
calculados os coeficientes de variação (CVs) das respostas para estimar qual a
influência daquele conjunto de fatores e interações como um todo. Assim, um CV
baixo indicava que nenhum dos fatores em questão eram influentes.

Para a consistência na linha do tempo, apenas a inserção de objetos na etapa de
carga não era suficiente para que o sistema operasse no seu estado estacionário
durante os experimentos. Isso porque, ao final da carga, cada objeto no banco de
dados tinha recebido apenas um acesso de cada centro de processamento de dados,
nenhuma réplica mestre teria migrado por efeito da localidade até esse momento.
Por isso, foi necessária uma etapa de aquecimento do sistema após a carga dos
dados antes de cada experimento de acordo com a localidade do experimento.

Foram realizados 4 estudos intermediários, descritos nas subseções seguintes.
Sempre que modo e localidade precisaram ser fixados, eles o foram
respectivamente em \textit{lt\_rec} e 50\%, valores que resultam em uma
quantidade balanceada de leituras e escritas locais e remotas. A latência,
quando necessária, foi fixada em 100 ms. Nos resultados, os percentis 10 e 90
representam respectivamente requisições locais e remotas.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de tamanho do sistema e \textit{benchmark}}
\label{sec:fatores_de_tamanho_do_sistema_e_benchmark}

As quantidades de nós de sistema e de instâncias do \textit{benchmark} não só
influenciavam as respostas, como também influenciavam questões operacionais
ligadas à reserva de nós -- pelas regras do Grid'5000, quanto maior a quantidade
de nós reservada, menor é o tempo de uso permitido. Portanto, um estudo foi
feito para definir a influência desses fatores. Os níveis usados foram os
seguintes, sendo o valor entre parênteses o identificador do fator, usado nas
tabelas com o resultado:

\begin{itemize}

\item Quantidade de nós do sistema (N): 8 e 16

\item Quantidade de instâncias do \textit{benchmark} (B): 2 e 4

\item Quantidade de threads em cada instância do \textit{benchmark} (T): 32 e 64

\end{itemize}

O resultado do estudo está na Tabela
\ref{tab:estudo_para_fatores_de_tamanho_do_sistema}. O tamanho do sistema teve a
maior influência nos resultados e as quantidades de instâncias do
\textit{benchmark} e de threads não foram desprezíveis, ainda mais ao se
considerar as interações entre elas. Apesar disso, esses fatores foram
desconsiderados devido ao excesso de fatores.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline

Operação & Percentil & N & B & T & NB & NT & BT & NBT\\ \hline

leitura & 10 & 30 & 18 & 22 & 10 & 8 & 7 & 4 \\ \hline

leitura & 90 & 65 & 13 & 15 & 3 & 4 & 0 & 0 \\ \hline

escrita & 10 & 96 & 2 & 1 & 0 & 0 & 0 & 0 \\ \hline

escrita & 90 & 65 & 15 & 13 & 3 & 3 & 0 & 0 \\ \hline

\end{tabular} \caption{Estudo fatores de tamanho do sistema.}
\label{tab:estudo_para_fatores_de_tamanho_do_sistema} \end{table}

\newpage Dados os resultados, os valores fixados foram:

\begin{itemize}

\item Quantidade de nós do sistema: 16

\item Quantidade de instâncias do \textit{benchmark}: 4

\item Quantidade de threads em cada instância do \textit{benchmark}: 32

\end{itemize}

Esses valores foram selecionados pois resultaram em uma configuração ``leve'',
evitando gargalos de rede e não sobrecarregando o sistema. Apesar de desejável,
uma quantidade maior de nós implicaria em falta de homogeneidade do hardware e
dificuldades operacionais devido às regras do Grid'5000.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de banco de dados} \label{sec:fatores_de_banco_de_dados}

Um estudo foi feito para dimensionar o tamanho do banco de dados, que afetava o
uso de memória e de banda nos nós. Os níveis usados foram os seguintes:

\begin{itemize}

\item Quantidade de objetos armazenados (Q): 64.000 e 256.000

\item Tamanho dos objetos armazenados (T): 100 e 10.000 bytes

\end{itemize}

O resultado do estudo está na Tabela
\ref{tab:estudo_para_fatores_de_banco_de_dados}. A quantidade de objetos não
afetou o desempenho do sistema. O tamanho dos objetos não afetou o desempenho
das requisições remotas, mas com relação às requisições locais apareceu com
100\% de influência. Apesar disso, o CV das requisições locais indicava que sua
influência não era tão grande -- 19\% para leituras e 16\% para escritas.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline

Operação & Percentil & Q & T & L & QT & QL & TL & QTL\\ \hline

leitura & 10 & 0 & 100 & 0 & 0 & 0 & 0 & 0 \\ \hline

leitura & 90 & 0 & 0 & 100 & 0 & 0 & 0 & 0 \\ \hline

escrita & 10 & 0 & 100 & 0 & 0 & 0 & 0 & 0 \\ \hline

escrita & 90 & 0 & 0 & 100 & 0 & 0 & 0 & 0 \\ \hline

\end{tabular} \caption{Estudo para fatores de banco de dados, L é a latência.}
\label{tab:estudo_para_fatores_de_banco_de_dados} \end{table}


Dados os resultados, os valores fixados foram:

\begin{itemize}

\item Quantidade de objetos armazenados: 128.000

\item Tamanho dos objetos armazenados (bytes): 500

\end{itemize}

O tempo de aquecimento dependia da quantidade de objetos armazenados, portanto
quanto menor essa quantidade, mais rápida era a execução dos experimentos. Por
outro lado, um número muito pequeno resultaria em excesso de conflitos. No caso
do tamanho dos objetos armazenados, o valor foi escolhido baseado em estudo dos
sistemas de caching no Facebook, que relata que 90\% dos objetos são menores do
que 500 bytes \cite{Atikoglu2012}.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de rede} \label{sec:fatores_de_rede}

Dado o objetivo do trabalho, o estudo para fatores de rede era um dos mais
importantes da etapa de seleção de fatores. Os níveis usados foram os seguintes:

\begin{itemize}

\item Latência da WAN (L): 100 e 300 ms

\item \textit{Jitter} da WAN (V): 1 e 60\%

\item Taxa de perda de pacotes na WAN (P): 0,01 e 0,3\%

\item Taxa de duplicação de pacotes na WAN (D): 0,05 e 5\%

\item Taxa de reordenação de pacotes na WAN (O): 0,05 e 5\%

\item Variante do TCP (T): CUBIC e H-TCP

\end{itemize}

Os níveis da latência foram baseados em um estudo que relata as latências entre
as regiões dos Amazon Web Services \cite{Sovran2011}, no qual a menor latência
foi 82 ms entre os centros de processamento de dados em cada costa dos EUA e a
maior foi 277 ms entre Irlanda e Singapura.
 
O projeto PingER serviu de base para os outros fatores \cite{PingER2013}. Para
janeiro de 2013, ele mostra uma média de latência de 238,062 ms com desvio
padrão de 142,996 ms, o que resulta em \textit{jitter} de 60\%. Os 11 meses
anteriores apresentavam valores semelhantes. A mediana da taxa de perda de
pacotes do último ano foi 0,178\%. A média da taxa de duplicação de pacotes em
janeiro de 2013 foi 0,006\%. Os valores usados no experimento para duplicação e
reordenação foram maiores do que os observados pelo PingER, mas mesmo assim não
influenciaram a resposta.

Tanto H-TCP quanto CUBIC foram projetados com foco em redes com largura de banda
e latências grandes (BDP alto) e foram escolhidos pois são citados nas
referências sobre otimizações da pilha TCP para WANs \cite{ESnet2012}.

No emulador de rede, a latência define o mínimo e o \textit{jitter} o máximo a
que ela pode chegar. Por exemplo, ao fazer a configuração de 100 ms de latência
e 60\% de variação, o emulador gera valores entre 100 ms e 160 ms. Os valores
gerados obedeciam a distribuição normal dentro da faixa de latência
especificada.

O resultado do estudo está na Tabela \ref{tab:estudo_para_fatores_de_rede}, em
que colunas das interações entre fatores com todas as células menores que 1\%
foram suprimidas por uma questão de espaço. As respostas das requisições locais
apresentaram CVs de 1\%, portanto as respectivas linhas também foram suprimidas
-- o que indica que a WAN não afeta requisições locais.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline

Operação & Percentil & L & V & P & D & O & T & LV\\ \hline

leitura & 90 & 72 & 21 & 1 & 0 & 0 & 0 & 6\\ \hline

escrita & 90 & 69 & 23 & 1 & 0 & 0 & 0 & 6\\ \hline

\end{tabular}

\caption{Estudo para fatores de rede.} \label{tab:estudo_para_fatores_de_rede}

\end{table}

A latência, o \textit{jitter} e a interação de primeira ordem entre eles
responderam pela quase totalidade dos resultados. Assim, os níveis escolhidos
para esses fatores nos experimentos foram:

\begin{itemize} \item Latência da WAN (ms): 0, 100, 200 e 300

\item \textit{Jitter} da WAN (\%): 0 e 60

\end{itemize}

Níveis nulos de latência e \textit{jitter} equivalem a ter todo o sistema
operando em uma LAN. Os resultados obtidos para esses casos foram usados como
auxílio na interpretação dos resultados, mas não foram considerados no estudo
final.

Os valores fixados dos fatores desconsiderados foram:

\begin{itemize}

\item Taxa de perda de pacotes na WAN (\%): 0

\item Taxa de duplicação de pacotes na WAN (\%): 0

\item Taxa de reordenação de pacotes na WAN (\%): 0

\item Variante do TCP: CUBIC

\end{itemize}

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de carga de trabalho}
\label{sec:fatores_de_carga_de_trabalho}

Este era um dos estudos mais importantes juntamente ao estudo para fatores de
rede. Os níveis usados foram os seguintes:

\begin{itemize}

\item Relação leitura/escrita (R): 2:1 e 10:1

\item Popularidade dos objetos (P): uniforme (a taxa de chegada de requisições
média para cada objeto é a mesma) e concentrada (a taxa de chegada segue uma
distribuição Pareto)

\item Localidade (X): 50\% (sem localidade) e 90\% (90\% dos acessos para
determinado objeto vindo de um centro de processamento de dados e 10\% do outro)

\end{itemize}

Como os modos possuem comportamentos diferentes para requisições locais e
remotas, os experimentos foram executados para cada modo. 

A análise da relação leitura/escrita e localidade não usou percentis, mas sim a
média do tempo de resposta de todas as requisições (leituras e escritas). Isso
porque o primeiro fator diz respeito à composição entre leituras e escritas e o
segundo altera a composição entre requisições locais e remotas, portanto esses
fatores não fazem sentido nos percentis separados por tipo de requisição. Por
exemplo, com localidade de 50\% percebe-se que o percentil 70 representa
requisições remotas, enquanto com localidade de 90\% o mesmo percentil
representa requisições locais. Se a análise fosse feita por percentis, essa
informação se perderia e localidade nunca teria influência.

O resultado do estudo está na Tabela
\ref{tab:estudo_para_fatores_de_carga_de_trabalho}, em que colunas com todas as
células menores do que 5\% foram suprimidas por uma questão de espaço.  Os
resultados para requisições locais apresentaram CVs em torno de 2\% para todos
os modos, o que indica que nenhum dos fatores influencia requisições locais.


\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|} \hline

Modo & R & X & P & L & RX & RL & XL & PL & XPL\\ \hline

\textit{ind1} & 19 & 12 & 2 & 31 & 0 & 2 & 6 & 6 & 8\\ \hline

\textit{ind2} & 50 & 0 & 0 & 39 & 0 & 11 & 0 & 0 & 0\\ \hline

\textit{lt\_qqer} & 25 & 30 & 0 & 19 & 9 & 6 & 8 & 0 & 0\\ \hline

\textit{lt\_rec} & 0 & 53 & 0 & 34 & 0 & 0 & 13 & 0 & 0\\ \hline

\end{tabular} \caption{Estudo para fatores de carga de trabalho, L é a
latência.} \label{tab:estudo_para_fatores_de_carga_de_trabalho}

\end{table}

Como esperado, localidade e latência influenciaram as respostas em geral. O
impacto de popularidade dos objetos é praticamente nulo. Apesar de alguns modos
aparentemente terem sido impactados pela relação leitura/escrita, esse impacto
foi consequência da relação entre requisições locais e remotas. Para
\textit{ind1}, tanto leituras quanto escritas são locais e a relação
leitura/escrita e suas interações com outros fatores impacta pouco esse modo.
Para \textit{lt\_rec}, leituras e escritas são locais ou remotas dependendo da
localidade e a relação leitura/escrita não impacta esse modo. Para
\textit{ind2}, todas as leituras são locais e metade das escritas é remota,
portanto quando a relação leitura/escrita muda, a relação entre requisições
locais e remotas muda proporcionalmente -- como esperado, esse modo é impactado
pela relação leitura/escrita. A mesma observação vale para \textit{lt\_qqer},
que tem todas as leituras locais e escritas dependendo da localidade, e também
sofre impacto da relação leitura/escrita. A relação leitura/escrita
provavelmente sofreria impacto caso o mecanismo de armazenamento fosse disco em
vez de memória, dado que escritas seriam afetadas pelo tempo de escrita no
disco, enquanto leituras poderiam ser mais rápidas pois parte delas seriam
servidas a partir do cache de disco.

Assim, apenas localidade foi selecionada como fator:

\begin{itemize}

\item Localidade (\%): 50 e 90

\end{itemize}

Os valores fixados dos fatores desconsiderados foram:

\begin{itemize}

\item Relação leitura/escrita: 2:1

\item Popularidade dos objetos: uniforme

\end{itemize}

%% ------------------------------------------------------------------------- %%
\section{Estudo Final} \label{sec:estudo_final}

O estudo final consistiu de um total de 64 experimentos, com os fatores
selecionados nos estudos 2\textsuperscript{k}, apresentados na
Tabela~\ref{tab:fatores_e_niveis_do_estudo_final}. Os experimentos usaram uma
quantidade de amostras tal que o nível de confiança fosse 99\% e a exatidão
fosse 1\% \cite{Jain1991}. O único caso com número de amostras menor que o
necessário foi \textit{lt\_rec} -- nesse caso, o mesmo nível de confiança foi
adotado e a exatidão foi 2\%. Duas replicações do estudo foram feitas para
estimar a variabilidade dos experimentos. A média dos CVs dos experimentos foi
1\% para leituras e 0,8\% para escritas.

\begin{table}[ht] \centering \begin{tabular}{|l|c|c|} \hline

\multicolumn{1}{|c|}{Fator} & \multicolumn{1}{|c|}{Níveis} &
\multicolumn{1}{|c|}{Total de níveis}\\ \hline

Modo & \textit{ind1}, \textit{ind2}, \textit{lt\_qqer} e \textit{lt\_rec} & 4\\
\hline

Latência da WAN (ms) & 0, 100, 200 e 300 & 4\\ \hline

\textit{Jitter} da WAN (\%) & 0 e 60 & 2\\ \hline

Localidade & 50\% e 90\% & 2\\ \hline

\end{tabular}

\caption{Fatores e níveis do estudo final.}
\label{tab:fatores_e_niveis_do_estudo_final}

\end{table}

Os resultados para latências de 100 ms, 200 ms e 300 ms apresentam o mesmo
comportamento, portanto a opção foi fazer a análise para um deles apenas. O
\textit{boxplot} para latência de rede de 200~ms está na Figura
\ref{fig:boxplot_dos_tempos_de_resposta}. Os casos em que a caixa não aparece
indicam que todas as requisições delimitadas pelos bigodes do \textit{boxplot}
eram locais. A mesma análise foi feita com carga máxima em vez de 15 operações/s
por thread. Como a
Figura~\ref{fig:boxplot_dos_tempos_de_resposta_para_carga_maxima} mostra, todos
os modos apresentaram um aumento nos tempos de resposta, mas mantiveram o
comportamento.

\begin{figure}[ht] \centering

\includegraphics[width=0.7\textwidth]{boxplot200.png}

\caption{\textit{Boxplot} dos tempos de resposta para 15 operações/s por
thread.} \label{fig:boxplot_dos_tempos_de_resposta} \end{figure}

\begin{figure}[ht] \centering

\includegraphics[width=0.7\textwidth]{boxplot200_max.png}

\caption{\textit{Boxplot} dos tempos de resposta para carga máxima por thread.}
\label{fig:boxplot_dos_tempos_de_resposta_para_carga_maxima} \end{figure}

No caso de leituras e localidade de 50\%, apenas \textit{lt\_rec} apresenta
requisições remotas. Uma porção pequena dessas leituras tem tempo de resposta
menor que a latência da rede, o que se explica pelo \textit{jitter} de até 60\%.

Para leituras e localidade de 90\%, \textit{lt\_rec} é beneficiado, mas continua
apresentando requisições remotas (valores atípicos no gráfico). No caso de
escritas e localidade de 50\%, \textit{lt\_rec} apresenta um desempenho um pouco
melhor que \textit{ind2} e \textit{lt\_qqer}. Isso ocorre pois o sistema está
menos carregado para esse modo do que para os outros, já que as leituras de
\textit{lt\_rec} são mais lentas. Esse fato é comprovado pela vazão dos modos
\textit{lt\_rec}, \textit{ev2} e \textit{lt\_qqer}, respectivamente, 594, 1072,
941 operações/s.

Para escritas e localidade de 90\%, \textit{lt\_rec} e \textit{lt\_qqer}
apresentam melhor desempenho devido à localidade, mas ainda apresentam
requisições remotas (valores atípicos no gráfico). Já \textit{ind2} continua
apresentando o mesmo perfil que para localidade de 50\%.

Os modos apresentaram o comportamento esperado. A hipótese de que a consistência
na linha do tempo é competitiva em termos de desempenho com a consistência em
momento indeterminado se confirma para o caso em que a localidade é alta e
principalmente quando leituras de ``qualquer versão'' são usadas.

%% ------------------------------------------------------------------------- %%
\section{Ameaças à Validade} \label{sec:ameacas_a_validade}

Parâmetros foram fixados e fatores tidos como influentes foram desconsiderados.
Com isso, estudos que usem outros valores para os parâmetros ou considerem
outros fatores podem apresentar resultados diferentes. Isso vale particularmente
para a quantidade de nós do sistema, que apareceu com influência relativamente
alta. Além disso, outras faixas de níveis podem levar a outros resultados
\cite{Jain1991}.

Os experimentos consideram que todos os nós sempre operam sem falhas.
Experimentos com o sistema operando em algum modo de falha (desde a falha de um
nó até de um centro de processamento de dados inteiro) devem apresentar
resultados diferentes dos obtidos nesse estudo, mas não foram realizados devido
a limitações de recursos da pesquisa.

%% ------------------------------------------------------------------------- %%
\section{Trabalhos Relacionados} \label{sec:trabalhos_relacionados}

Uma abordagem comum na literatura de sistemas distribuídos é a proposta de um
novo conceito e a implementação de um sistema que use esse conceito seguida de
uma análise de seu desempenho. Tanto o artigo sobre o Dynamo \cite{DeCandia2007}
quanto o sobre o PNUTS \cite{Cooper2008} apresentam análises de desempenho,
sendo que apenas o segundo faz uma análise baseada na carga de trabalho. Há uma
segunda publicação com experimentos com o PNUTS que analisa o consumo de banda
de diferentes políticas de replicação em uma WAN \cite{Kadambi2011}.

Muitos trabalhos apresentam análises de desempenho de sistemas de armazenamento
que usam replicação sobre WANs. Na maior parte dos casos, o objetivo desses
sistemas é provar outros conceitos além da eficiência do modelo de consistência
escolhido por eles. O COPS usa consistência causal+, que é semelhante à
consistência causal com algumas garantia a mais, e implementa transações
\cite{Lloyd2011}. O Scatter propõe uma arquitetura ao mesmo tempo escalável e
com consistência forte \cite{Glendenning2011}. O Windows Azure provê um sistema
de armazenamento na nuvem com consistência forte \cite{Calder2011}. O Megastore
usa Paxos para implementar consistência forte \cite{Baker2011}. Nenhum desses
trabalhos apresenta comparações com outros sistemas ou com outros modelos de
consistência. Como eles não usam uma aplicação para execução de testes ou
ambiente em comum, é difícil fazer comparações a partir deles.

As diferentes configurações de consistência no Cassandra e sua disponibilidade e
desempenho foram analisadas em \cite{Beyer2011}, que conclui que configurações
que oferecem consistência mais rígida apresentam pior desempenho. Desempenho e
disponibilidade de replicação mestre-escravo e em cadeia são comparados em
\cite{vanRenesse2004}, cada uma delas usando consistência forte e consistência
em momento indeterminado. Nenhum desses estudos leva em consideração operação
sobre WAN nem diferentes cargas de trabalho.

Um estudo com proposta mais próxima da deste trabalho é a comparação usando
diferentes cargas de trabalho feita entre Cassandra, HBase, PNUTS e MySQL
particionado horizontalmente \cite{Cooper2010}. Os resultados servem como uma
comparação entre esses sistemas, mas dizem menos sobre seus modelos de
consistência, dado que os sistemas apresentam arquiteturas e configurações
diferentes. Além disso, os testes são feitos em uma LAN, não em uma WAN.

%% ------------------------------------------------------------------------- %%
\section{Conclusões} \label{sec:conclusoes}

Este trabalho comparou o desempenho de um mesmo sistema de armazenamento usando
dois modelos de consistência diferentes operando em uma WAN. Além disso,
apresentou resultados sobre a influência de diferentes fatores e suas interações
sobre o desempenho do mesmo sistema. A consistência na linha do tempo se mostrou
competitiva com a consistência em momento indeterminado quando a localidade de
escritas é alta e quando as leituras são de ``qualquer versão''.

As principais vantagens da consistência na linha do tempo sobre em momento
indeterminado são a garantia de que as réplicas não são atualizadas com valores
divergentes e a existência de uma réplica mestre que corresponde à versão mais
recente. Um cenário interessante para seu uso é o caso em que a aplicação tolera
inconsistências na maioria das leituras, mas em algumas poucas situações precisa
da versão consistente. Já sua principal desvantagem é a indisponibilidade da
réplica mestre impedir escritas e leituras consistentes. Outra desvantagem é que
mesmo sendo competitiva, ela apresenta variabilidade relativamente alta nos
tempos de resposta. Para aplicações em que os requisitos de tempos de resposta
são dados pelo percentil 99,9, como é o caso da Amazon \cite{DeCandia2007}, a
consistência na linha do tempo não é adequada.

%% ------------------------------------------------------------------------- %%
\section{Agradecimentos} \label{sec:agradecimentos}

Os experimentos apresentados neste trabalho foram realizados utilizando a
plataforma para experimentos Grid'5000, desenvolvida pela ação de
desenvolvimento ALADDIN INRIA com o apoio do CNRS, RENATER e várias
universidades, bem como outros órgãos de financiamento.

\section{Referências} \bibliographystyle{sbc} \bibliography{bibliografia}

\end{document}
