\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

\usepackage[brazil]{babel}   \usepackage[latin1]{inputenc}  
     
\sloppy

\hyphenation{re-la-xa-do re-pre-sen-ta Facebook}

\title{Desempenho de Sistemas com Dados Georeplicados\\ com Consistência em
Momento Indeterminado e\\ na Linha do Tempo}

\author{Mauricio De Diana\inst{1}, Marco Aurélio Gerosa\inst{1}}

\address{Instituto de Matemática e Estatística -- Universidade de São Paulo
(USP)\\ \email{\{mdediana,gerosa\}@ime.usp.br}}

\begin{document} 

\maketitle

\begin{abstract} This meta-paper describes the style to be used in articles and
short papers for SBC conferences. For papers in English, you should add just an
abstract while for the papers in Portuguese, we also ask for an abstract in
Portuguese (``resumo''). In both cases, abstracts should not have more than 10
lines and must be in the first page of the paper.  \end{abstract}
     
\begin{resumo}

Sistemas web de larga escala replicam dados entre centros de processamento de
dados por questões de desempenho e disponibilidade. Um modelo de consistência
define um determinado balanço entre esses dois requisitos e a consistência dos
dados entre réplicas. Este trabalho comparou experimentalmente o desempenho de
sistemas de armazenamento georeplicados usando consistência em momento
indeterminado e consistência na linha do tempo. As medições mostraram que,
dependendo da carga de trabalho e das condições de rede, os desempenhos desses
modelos de consistência são semelhantes. Esse resultado pode auxiliar
responsáveis por sistemas web de larga escala nas estimativas de custo de
desenvolvimento e de planejamento de capacidade.

\end{resumo}

%% ------------------------------------------------------------------------- %%
\section{Introdução} \label{sec:introducao}

Para atender centenas de milhares de usuários ininterruptamente em sistemas web
de larga escala, dados são replicados em milhares de servidores distribuídos em
múltiplos centros de processamento de dados em diferentes localizações
geográficas. O principal problema do uso de replicação em redes de longa
distância (WAN) é que manter as réplicas sempre consistentes entre si
tipicamente implica em sacrificar outros requisitos também importantes, como
desempenho ou disponibilidade. Um motivo para divergência entre réplicas é que
a replicação entre centros de processamento de dados pode apresentar centenas
de milissegundos de latência, período durante o qual as réplicas podem
divergir.  Essa latência é resultado não só das distâncias físicas entre os
nós, mas também de limitações na largura de banda disponível e congestionamento
de rede.  Outro motivo de divergência entre réplicas é a falha temporária de um
nó, que deixa de receber atualizações por um período de tempo. Um terceiro
motivo é o particionamento de rede, causado por exemplo por uma falha em um
equipamento ou enlace de rede que impeça a comunicação entre réplicas.

Com isso, desenvolvedores e administradores de sistemas web de larga escala
buscam um balanço entre disponibilidade, desempenho e consistência dos dados.
Uma decisão comum em vários desses sistemas é o relaxamento da consistência em
troca de alta disponibilidade e baixa latência. Por outro lado, modelos de
consistência mais relaxados permitem que conflitos entre réplicas aconteçam.
Com isso, o código da aplicação fica mais complexo pois mecanismos de resolução
de conflitos e ações de compensação precisam ser implementados.

Este trabalho é um comparativo de desempenho de um sistema de armazenamento
georeplicado usando dois modelos de consistência diferentes. Um deles, a
consistência em momento indeterminado (\emph{eventual consistency}\footnote{O
termo \emph{eventual consistency} às vezes é erroneamente traduzido para o
português como consistência eventual. Mas \emph{eventual} é um falso cognato,
já que em inglês ele indica que algo certamente acontecerá no futuro, mas em
português significa que algo pode ou não acontecer no futuro. Daí a opção de
traduzir \emph{eventual} por ``em momento indeterminado''.}) é um modelo mais
relaxado e se tornou especialmente popular após a publicação sobre o Dynamo da
Amazon \cite{DeCandia2007,Lakshman2010,Voldemort,Riak}. Um modelo de
consistência para sistemas georeplicados menos popular, que busca um meio termo
entre consistência forte e consistência em momento indeterminado é a
consistência na linha do tempo, usada no PNUTS do Yahoo
\cite{Cooper2008,Abadi2010}. Ela pode ser uma opção interessante por
simplificar a programação, desde que seu desempenho seja próximo ao da
consistência em momento indeterminado e a aplicação tolere níveis mais baixos
de disponibilidade.

A Seção~\ref{sec:consistencia_em_momento_indeterminado_e_na_linha_do_tempo}
apresenta detalhes dos modelos de consistência usados no estudo e as situações
que favorecem o uso de cada um deles.

%% ------------------------------------------------------------------------- %%
\section{Consistência em Momento Indeterminado e na Linha do Tempo}
\label{sec:consistencia_em_momento_indeterminado_e_na_linha_do_tempo}

A consistência em momento indeterminado garante que as réplicas vão sempre
convergir em algum momento no futuro desde que novas atualizações cessem.
Enquanto atualizações estiverem acontecendo, réplicas inconsistentes são
possíveis, e clientes podem acessar dados desatualizados ou divergentes. Por
isso, o sistema precisa implementar algoritmos de detecção e resolução de
conflitos.

Quóruns são utilizados para aumento da consistência, com diminuição da
disponibilidade do sistema sempre que um determinado quórum não é atingido
\cite{Vogels2009}. Seja o fator de replicação N a quantidade de réplicas
existentes de um objeto, R a quantidade de réplicas que precisam concordar com
o mesmo valor para que uma leitura seja bem sucedida e W a quantidade de
réplicas que precisam confirmar a execução da escrita para que ela seja bem
sucedida. Nas situações em que $N >= R + W$, existe a possibilidade do
surgimento de conflitos. Por exemplo, em um sistema composto dos nós N1, N2 e
N3 e $N = 3$, $R = 1$ e $N = 2$ é possível que um cliente escreva em um
determinado objeto em N1, e esse valor seja replicado para N2, mas ocorra um
particionamento na rede antes da escrita atingir N3. Dado que $R = 1$, um
cliente solicitando a leitura desse objeto em N3 lerá o valor anterior do
objeto. Uma opção para evitar o conflito é definir $N$, $R$ e $W$ tal que $N <
R + W$, de forma que sempre haja intersecção entre os subconjuntos de nós
usados para leitura e escrita. O contraponto nesse caso é que a disponibilidade
do sistema foi diminuída.

Apesar de disponibilidade ser um requisito prioritário para a maioria das
aplicações web, existem aplicações que necessitam de modelos de consistência
mais rígidos para funcionar corretamente. Por exemplo, uma aplicação de leilão
não pode permitir conflitos no histórico de lances de um produto. Num sistema
que usa consistência em momento indeterminado, no caso de uma falha que divida
a rede em duas partições, usuários em cada partição têm uma visão própria do
histórico de lances, equivalente a dois leilões simultâneos sobre o mesmo item.

A consistência na linha do tempo é um modelo de consistência que abre mão de
disponibilidade em algumas situações em troca de consistência
\cite{Cooper2008}. Para cada objeto armazenado, esse modelo de consistência
permite atualizações em apenas uma de suas réplicas (réplica mestre), evitando
assim a possibilidade de conflitos ao mesmo tempo em que evita o uso de
bloqueios e replicação síncrona. Devido à replicação assíncrona, réplicas podem
ter valores desatualizados devido à latência de rede ou falhas, mas a qualquer
instante sabe-se qual é a réplica com o valor mais recente.  Os clientes
escolhem em cada acesso se aceitam como resposta apenas o valor mais recente ou
se aceitam valores desatualizados. Além disso, como a réplica mestre define uma
ordem de aplicação de atualizações nas outras réplicas, divergências não
acontecem e mecanismos de detecção e resolução de conflitos não são
necessários. A principal desvantagem da consistência na linha do tempo é que a
existência de uma réplica mestre implica que escritas e leituras consistentes
(leituras do valor mais recente) ficam indisponíveis em caso de uma falha que
impeça um cliente de acessar essa réplica.

O maior fator de impacto no desempenho da consistência na linha do tempo é o
fato de que todas as escritas e leituras consistentes que não são feitas no
centro de processamento de dados em que está a réplica mestre incorrem no custo
de latência da WAN. Entretanto, em aplicações como redes sociais, por exemplo,
é de se esperar que haja uma grande quantidade de acessos locais (a maioria dos
usuários acessa o sistema de um único país e tem a maioria de seus contatos no
mesmo país) e que a relação escrita/leitura seja baixa (cada item criado, como
uma postagem ou um comentário, seja lido diversas vezes). De fato, os autores
do PNUTS indicam que em sua rede social 60\% dos acessos é local e a relação
escrita/leitura observada é de 0,06 \cite{Kadambi2011}. Eles indicam também que
outras aplicações chegam a ter 85\% dos acessos locais \cite{Cooper2008}. Dado
isso, eles usam a estratégia de sempre mover dinamicamente a réplica mestre
para o centro de processamento de dados que processa a maior quantidade de
requisições para dado objeto. Com isso, em uma aplicação na qual a quantidade
de leituras é muito maior do que a quantidade de escritas, o custo de latência
de rede é baixo, em especial se as leituras não precisarem necessariamente do
valor mais recente.

%% ------------------------------------------------------------------------- %%
\section{Planejamento dos Experimentos}
\label{sec:planejamento_dos_experimentos}

A principal hipótese deste trabalho era que um sistema georeplicado usando
consistência na linha do tempo apresentaria um desempenho competitivo com a
consistência em momento indeterminado para algumas cargas de trabalho, como uma
que apresentasse localidade alta, por exemplo. Essa hipótese se baseava em uma
segunda hipótese, a de que os tempos de resposta das requisições para o sistema
seriam dominadas pela latência (e variação da latência) da WAN. Um exemplo de
fenômeno que poderia invalidar a hipótese seria a réplica mestre se comportar
como gargalo na consistência na linha do tempo. Essa hipótese foi verificada
pela distribuição acumulada dos tempos de resposta para cada modo usado no
estudo.

Três técnicas são comumente usadas na análise de desempenho de sistemas:
simulação, modelagem analítica e medição \cite{Jain1991}. Dada a complexidade
dos sistemas considerados neste estudo e do ambiente em que operam, é difícil
criar simuladores ou modelos que considerem muitos dos parâmetros que afetam
seu desempenho. Para serem viáveis nesse contexto, essas técnicas fazem uso de
diversas simplificações que afetam a precisão dos resultados do estudo. Por
outro lado, as principais dificuldades para o uso de medição são a necessidade
de um sistema pronto para ser usado, o tempo disponível para o estudo e as
ferramentas disponíveis. No caso deste estudo, nenhum dos três representava
empecilho, portanto medição foi escolhida.

Como medição foi a técnica de avaliação escolhida, era necessária a escolha do
sistema que seria o objeto do estudo. Como não foram encontradas soluções de
software livre com consistência na linha do tempo, ela tinha que ser
implementada em algum sitema com consistência em momento indeterminado. A opção
foi pelo Riak. Sua arquitetura é próxima da arquitetura do Dynamo, e é escrito
em Erlang, linguagem com foco em sistemas distribuídos, o que facilitou a
implementação. Além do novo modelo de consistência, um algoritmo de
particionamento que garante que existe ao menos um réplica em cada centro de
processamento de dados.

Como \emph{benchmark}, foi usado o Basho Bench, específico para Riak. Ele foi
adaptado para executar instâncias em nós diferentes, uma para cada centro de
dados.

Os experimentos emularam uma WAN pelo uso da ferramenta traffic control (tc).
Mais especificamente para emulação da WAN, o
netem\footnote{\url{http://www.linuxfoundation.org/collaborate/workgroups/networking/netem}}
foi usado. Ele provê funcionalidade para inserção de latência de rede, variação
da latência, perda de pacotes, pacotes duplicados, corrompidos e/ou fora de
ordem. As configurações de rede foram alteradas nos experimentos de acordo com
recomendações sobre otimizações de sistemas Linux para quando esses se
comunicam por WANs \cite{Jones2006,ESNet2012}. Um exemplo de otmização é mudar
o tamanho dos buffers de transmissão e recepção para que sejam o dobro do BDP.

O estudo usou experimentos fatorias. Experimentos fatoriais consistem da
combinação de dois ou mais fatores em cada experimento que compõe o estudo
\cite{Jain1991}. Um projeto de experimentos fatoriais completo é constituído
por experimentos com todas as combinações possíveis de fatores e seus níveis.
Esse tipo de projeto de experimentos tem a vantagem de identificar com precisão
a influência de todos os fatores e suas interações nas variáveis de resposta.
Mas quanto maior a quantidade de fatores e de níveis em um estudo experimental,
maior a quantidade de recursos necessários para sua execução. Normalmente os
fatores não afetam igualmente as variáveis de resposta, pelo contrário, é comum
alguns poucos fatores explicarem a maior parte dos efeitos na resposta
\cite{Jain1991}. Para esses casos, um projeto de experimentos fatoriais
2\textsuperscript{k}, que é um tipo de projeto de experimentos completo, é
utilizado para fazer uma triagem dos fatores, identificando quais deles são os
mais influentes.

A seção seguinte mostra quais foram os parâmetros inicialmente levantados e
como experimentos fatoriais 2\textsuperscript{k} foram usados para selecionar
os fatores para o estudo final.

%% ------------------------------------------------------------------------- %%
\section{Parâmetros e Fatores}

Foi feito um levantamento de uma lista com 33 parâmetros, dos quais 16 foram
fixados por limitação de recursos ou por não serem foco do estudo. A seleção
inicial de fatores foi formada pelos 17 parâmetros restantes. 

Dos parâmetros iniciais, os que foram fixados e seus respectivos valores são:

\begin{itemize}

\item \textbf{Aglomerado:} Os experimentos usaram o aglomerado \emph{sol} no
Grid'5000. Os nós desse aglomerado possuem CPU AMD Opteron 2218 2.6 GHz, 4 GB
de memória e placa de rede de 1 Gb/s. Os nós do aglomerado estão todos ligados
a um comutador Foundry FastIron Super X.

\item \textbf{Mecanismo de armazenamento:} Ao usar memória como mecanismo de
armazenamento evitou-se ter que considerar os efeitos de disco, cache de disco
e sua interação com a quantidade de memória disponível. Isso por sua vez
colaborou para que os únicos efeitos de E/S observados fossem devidos à rede.

\item \textbf{Capacidade dos centros de processamento de dados:} Os centros de
processamento de dados têm a mesma capacidade, com a mesma quantidade de nós e
os nós têm a mesma configuração de hardware, resultando em um sistema simétrico
e homogêneo.

\item \textbf{Algoritmo de particionamento das chaves:} O algoritmo padrão do
Riak foi usado (espalhamento consistente), configurado com 512 partições. Esse
valor satisfaz as duas condições descritas na documentação do Riak: ser uma
potência de 2 e resultar em ao menos 10 partições por nó.

\item \textbf{Fator de replicação ($N$):} 3. Valor que resulta em um balanço
razoável entre desempenho, disponibilidade e durabilidade em aplicações reais
\cite{DeCandia2007}.

\item \textbf{Limiar de migração (para consistência na linha do tempo):} 3. O
limiar de migração é o valor no qual uma réplica mestre migra de um centro de
processamento de dados para outro. O valor escolhido foi o padrão usado pelo
PNUTS \cite{Cooper2008}.

\item \textbf{Interface de acesso:} HTTP. O Riak também dá suporte a Protocol
Buffers\footnote{\url{http://code.google.com/p/protobuf/}}, mais eficiente que
a interface HTTP. Apesar disso, a opção foi pelo uso de HTTP pois eficiência da
interface não era tão relevante para os experimentos dado que a carga sobre o
sistema era controlada, e implementar os parâmetros da consistência na linha do
tempo na interface HTTP era mais simples.

\item \textbf{Nível de log:} WARN. Alguns experimentos exploratórios mostraram
perda de desempenho quando o  nível de log estava em INFO. De qualquer forma,
como a carga sobre o sistema era controlada, esse parâmetro era pouco
relevante.

\item \textbf{Configuração de hardware dos dispositivos de rede intermediários
(comutadores, roteadores, etc.):} O único dispositivo de rede no aglomerado
usado no estudo era um comutador. Testes mostraram que não existiam gargalos no
comutador mesmo nos experimentos com maior consumo de banda.

\item \textbf{Topologia da rede:} Topologia da rede em estrela do aglomerado
usado nos experimentos.

\item \textbf{Largura de banda da LAN:} 1 Gb/s. Essa é a largura de banda
disponível nas placas de rede dos nós do aglomerado e não foram encontrados
indícios de que o comutador seria um gargalo. Tomando o AWS como base, estudos
informais indicam que é essa a largura de banda observada dentro de um mesmo
centro de processamento de dados por instâncias com perfil de E/S ``Alto'' (por
exemplo, uma instância M1 Grande) \cite{Thorsten2007,Pujol2012}.

\item \textbf{Latência da LAN:} Latência do aglomerado utilizado no estudo. Um
teste com ping com 60 amostras espaçadas em 5 s no aglomerado mediu 167 $\mu$s
de latência média.
% ping -i 5 -c 60 sol-20

\item \textbf{Variação de latência da LAN:} Variação de latência do aglomerado
utilizado no estudo. A mesma medição feita para a latência mostrou desvio
padrão de 90 $\mu$s.

\item \textbf{Largura de banda da WAN:} 100 Mb/s. Um estudo informal entre os
serviços EC2 e S3 da Amazon com 9 segmentos de rede entre eles (indício de que
estão em centros de processamento de dados diferentes) mediu 400 Mb/s
\cite{Thorsten2007}. Outro estudo cita que é comum medir 100 Mb/s como largura
de banda entre zonas de disponibilidade \cite{Pujol2012}.

\item \textbf{Quantidade de enlaces de WAN:} 1. Um único enlace significa que o
estudo usou dois centros de processamento de dados. Esse valor simplificou a
modificação do algoritmo de particionamento do Riak e a análise dos resultados,
que não precisou considerar heterogeneidade da rede.

\item \textbf{Taxa de chegada de requisições:} 15 operações/s para cada thread
de cada instância do \emph{benchmark}. Esse valor foi usado pois esse parâmetro
se relaciona diretamente com a quantidade de threads por instância do
\emph{benchmark}. Assim, considerando que threads por instância foi
inicialmente considerado um fator, a taxa de chegada foi fixada.

\end{itemize}

Outros 17 parâmetros compunham a seleção inicial de fatores:

\begin{itemize}

\item Quantidade de nós do sistema

\item Quantidade de instâncias do \emph{benchmark}

\item Quantidade de threads por instância do \emph{benchmark}

\item Quantidade de objetos armazenados

\item Tamanho dos objetos armazenados

\item Modelo de consistência

\item Configuração de replicação -- $R$ e $W$ (para consistência em momento
indeterminado)

\item Latência da WAN

\item Variação da latência da WAN

\item Taxa de perda de pacotes na WAN

\item Taxa de duplicação de pacotes na WAN

\item Taxa de reordenação de pacotes na WAN

\item Variação de TCP

\item Relação leitura/escrita

\item Popularidade dos objetos

\item Localidade

\item Versão requisitada nas leituras (para consistência na linha do tempo)

\end{itemize}

Uma abordagem possível para a seleção final de fatores seria agrupar todos os
fatores levantados em um único projeto de experimentos fatoriais
2\textsuperscript{k}. O problema é que mesmo com apenas dois níveis por fator,
a quantidade final de experimentos seria proibitiva.

A opção adotada para lidar com o excesso de fatores foi dividi-los em grupos
menores e realizar experimentos para cada grupo. O principal problema de fazer
essa separação é o fato de a comparação da influência de fatores de grupos
diferentes ser perdida. Por exemplo, localidade e quantidade de nós de sistema
foram tratados em estudos diferentes e cada um apareceu como o fator mais
influente do estudo de que fez parte. Como eles não fizeram parte do mesmo
estudo, a informação de qual deles é o mais influente foi perdida, bem como a
informação sobre a influência da interação entre eles. Se um fosse muito mais
influente do que o outro e a interação entre eles fosse baixa, a decisão de
fixar o menos influente não teria consequências. Mas sem essa informação, fixar
um deles representava ameaça à validade do estudo.

A maioria desses fatores era suscetível a interações com fatores de rede, como
o tamanho dos objetos armazenados, por exemplo. A latência de rede em
particular havia se mostrado muito influente em estudos exploratórios, fato
confirmado posteriormente pelo estudo para fatores de rede. Dado isso, a
abordagem adotada foi usar a latência como um representante da rede nos outros
estudos fatoriais.

Existem outras situações em que desconsiderar um fator que aparece como
influente não implica necessariamente em ameaça à validade. Existem casos onde
as respostas de todos os experimentos de um estudo são semelhates,
independentemente dos níveis. Para tratar esses casos, também foram calculados
os coeficientes de variação\footnote{O coeficiente de variação é a divisão do
desvio padrão pela média e é uma maneira de representar a variabilidade dos
dados desconsiderando sua ordem de grandeza} (CVs) das respostas para estimar
qual a influência daquele conjunto de fatores e interações como um todo. Assim,
quando o CV era baixo (1\%, por exemplo), nenhum dos fatores usados no estudo
era influente, já que nenhuma combinação de fatores e níveis resultou em
variação significativa da resposta.

Os tempos de resposta das requisições remotas dominam a média dos tempos de
resposta pois são ordens de grandeza maiores que os das requisições locais. Por
isso, a análise da maioria dos estudos é feita por percentis em vez de médias
-- percentis baixos representam requisições locais e percentis altos
representam requisições remotas. Também é feita a distinção entre escritas e
leituras dada a diferença de natureza dessas operações.

Por último, um comentário sobre a etapa de aquecimento. Como localidade era um
fator, apenas a inserção de objetos na etapa de carga não era suficiente para
que o sistema operasse no seu estado estacionário durante os experimentos para
a consistência na linha do tempo. Isso porque, ao final da carga, cada objeto
no banco de dados tinha recebido apenas um acesso de cada centro de
processamento de dados, nenhuma réplica mestre teria migrado por efeito da
localidade até esse momento. Por isso, o aquecimento era necessário após a
carga. Já a consistência em momento indeterminado não era sujeita à influência
direta de localidade, portanto não precisava de aquecimento.

Três fatores receberam um tratamento diferente ao longo do experimento: modelo
de consistência, configuração de replicação (para consistência em momento
indeterminado) e versão requisitada nas leituras (para consistência na linha do
tempo). Isso foi feito pois as combinações entre esses fatores definem
configurações do sistema de armazenamento que resultam em proporções de
requisições locais e remotas diferentes. Assim, esses fatores foram tratados
como um único fator chamado modo, descrito na Subseção~\ref{sec:modo}. Projetos
de experimentos fatoriais 2\textsuperscript{k} foram realizados para cada um
dos fatores restantes e são descritos nas subseções subsequentes. Sempre que
modo e localidade precisaram ser fixados, eles o foram respectivamente em
\emph{lt\_rec} e 50\%. Esses valores foram escolhidos pois por meio deles
obtém-se uma quantidade balanceada de leituras e escritas locais e remotas. Já
a latência foi fixada em 100 ms.

%% ------------------------------------------------------------------------- %%
\subsection{Modo} \label{sec:modo}

Os modos adotados foram:

\begin{itemize}

\item \emph{ind1}: Consistência em momento indeterminado com $W$ = 1 e $R$ = 1

\item \emph{ind2}: Consistência em momento indeterminado com $W$ = 2 e $R$ = 1

\item \emph{lt\_qqer}: Consistência na linha do tempo com leituras de qualquer
versão

\item \emph{lt\_rec}: Consistência na linha do tempo com leituras da versão
mais recente

\end{itemize}

Todas as configurações usam $N = 3$. Como existe ao menos uma réplica em cada
centro de processamento de dados, duas situações são possíveis com relação à
localização das réplicas do ponto de vista do nó que recebe uma requisição: uma
local e duas remotas ou duas locais e uma remota. Dado isso, o modo \emph{ind1}
resulta em todas as leituras e escritas locais. O modo \emph{ind2} resulta em
todas as leituras locais e metade das escritas local e a outra metade remota. O
modo \emph{lt\_qqer} resulta em todas as leituras locais e a quantidade de
escritas dependente da localidade dos acessos. Finalmente, o modo
\emph{lt\_rec} resulta tanto em leituras quanto escritas dependentes da
localidade.

Os modos foram escolhidos de forma a representar situações encontradas em
aplicações web e ao mesmo tempo limitar a quantidade de níveis. Assim,
consistência na linha do tempo com leituras de versões específicas não foi
considerada já que ela é um meio termo entre leituras de ``versão mais
recente'' e leituras de ``qualquer versão''. Consistência em momento
indeterminado com $W = 1$ e $R = 2$ não foi considerada pois sua semântica é
similar a $W = 2$ e $R = 1$, mas teria seu desempenho prejudicado considerando
que leituras predominam nas relações leitura/escrita usadas nos experimentos.

Esses modos implicam em trocas além de desempenho e consistência. A principal é
durabilidade, que para \emph{ind2} é mais alta do que para os outros casos, em
que a confirmação de escrita de uma única réplica é suficiente.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de tamanho do sistema e \emph{benchmark}}
\label{sec:fatores_de_tamanho_do_sistema_e_benchmark}

As quantidades de nós de sistema e de instâncias do \emph{benchmark} não só
influenciam as respostas, como também afetam questões operacionais, dado que
quanto mais nós são usados, maiores as dificuldades de conseguir reservá-los no
Grid'5000.  Portanto, um estudo foi feito para definir a influência desses
fatores e achar valores que representassem um compromisso razoável entre
tamanho dos experimentos e as questões operacionais.

Os níveis selecionados foram (entre parênteses está o identificador do fator na
Tabela~\ref{tab:estudo_para_quantidade_de_nos_do_sistema}):

\begin{itemize}

\item Quantidade de nós do sistema (N): 8 e 16

\item Quantidade de instâncias do \emph{benchmark} (B): 2 e 4

\item Quantidade de threads em cada instância do \emph{benchmark} (T): 32 e 64

\end{itemize}

A quantidade de partições usadas pelo Riak deve ser uma potência de 2. Uma
forma de manter a simetria do sistema foi adotar potências de 2 para os níveis
da quantidade de nós do sistema, garantindo assim a mesma quantidade de
partições por nó. Além disso, esse valor era limitado pela quantidade de nós
disponíveis no aglomerado usado. Fazer o mesmo para quantidade de instâncias do
\emph{benchmark} e quantidade de threads por instância foi uma forma de
balancear a carga média tanto por nó quanto por partição.

O resultado do estudo está na Tabela
\ref{tab:estudo_para_quantidade_de_nos_do_sistema}.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline

Operação & Percentil & N & B & T & NB & NT & BT & NBT\\ \hline

leitura & 10 & 30 & 18 & 22 & 10 & 8 & 7 & 4 \\ \hline

leitura & 90 & 65 & 13 & 15 & 3 & 4 & 0 & 0 \\ \hline

escrita & 10 & 96 & 2 & 1 & 0 & 0 & 0 & 0 \\ \hline

escrita & 90 & 65 & 15 & 13 & 3 & 3 & 0 & 0 \\ \hline

\end{tabular} \caption{Estudo para tamanho do sistema.}
\label{tab:estudo_para_quantidade_de_nos_do_sistema} \end{table}

Na maioria dos casos, o tamanho do sistema tem a maior influência nos
resultados e a quantidade de instâncias do \emph{benchmark} e a quantidade de
threads não são desprezíveis, ainda mais ao se considerar as interações entre
elas. Apesar disso, esses fatores foram desconsiderados devido ao excesso de
fatores. Dessa forma, os valores fixados foram:

\begin{itemize}

\item Quantidade de nós do sistema: 16 (maior valor)

\item Quantidade de instâncias do \emph{benchmark}: 4 (maior valor)

\item Quantidade de threads em cada instância do \emph{benchmark}: 32 (menor
valor)

\end{itemize}

Esses valores foram selecionados pois resultaram em uma configuração ``leve'',
evitando gargalos de rede e não sobrecarregando o sistema. Ao mesmo tempo, a
quantidade total de nós necessária para os experimentos se enquadrava nas
limitações de recursos do aglomerado.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de banco de dados} \label{sec:fatores_de_banco_de_dados}

Um estudo foi feito para dimensionar o tamanho do banco de dados, que afeta o
uso de memória e de banda. Os experimentos consideraram a latência como fator
para verificar a importância relativa entre esses fatores e a rede.

Os níveis selecionados foram (entre parênteses está o identificador do fator na
Tabela~\ref{tab:estudo_para_quantidade_e_tamanho_dos_objetos_armazenados}, L
representa latência):

\begin{itemize}

\item Quantidade de objetos armazenados (Q): 64.000 e 256.000

\item Tamanho dos objetos armazenados (T): 100 e 10.000 bytes

\end{itemize}

O resultado do estudo está na Tabela
\ref{tab:estudo_para_quantidade_e_tamanho_dos_objetos_armazenados}.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline

Operação & Percentil & Q & T & L & QT & QL & TL & QTL\\ \hline

leitura & 10 & 0 & 100 & 0 & 0 & 0 & 0 & 0 \\ \hline

leitura & 90 & 0 & 0 & 100 & 0 & 0 & 0 & 0 \\ \hline

escrita & 10 & 0 & 100 & 0 & 0 & 0 & 0 & 0 \\ \hline

escrita & 90 & 0 & 0 & 100 & 0 & 0 & 0 & 0 \\ \hline

\end{tabular} \caption{Estudo para quantidade e tamanho dos objetos
armazenados.}
\label{tab:estudo_para_quantidade_e_tamanho_dos_objetos_armazenados}
\end{table}

A quantidade de objetos não afeta o desempenho do sistema. O tamanho dos
objetos não afeta o desempenho das requisições remotas, mas com relação às
requisições locais aparece com 100\% de influência. Apesar disso, o CV das
requisições locais indica que sua influência na prática não é tão grande --
19\% para leituras e 16\% para escritas. Assim, os valores fixados foram:

\begin{itemize}

\item Quantidade de objetos armazenados: 128.000

\item Tamanho dos objetos armazenados (bytes): 500

\end{itemize}

Como o tempo de aquecimento depende da quantidade de objetos armazenados,
quanto menor essa quantidade, mais rápida é a execução dos experimentos. Por
outro lado, a opção foi por um número intermediário de modo a evitar um excesso
de conflitos. Já no caso do tamanho dos objetos armazenados, o valor foi
escolhido baseado em um estudo dos sistemas de caching distribuído no Facebook,
que relata que 90\% dos objetos nesses sistemas são menores do que 500 bytes
\cite{Atikoglu2012}.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de rede} \label{sec:fatores_de_rede}

Dado o objetivo do trabalho, o estudo para fatores de rede era um dos mais
importantes da etapa de seleção de fatores.

Os níveis inicialmente selecionados foram (entre parêenteses está o
identificador do fator na Tabela~\ref{tab:estudo_para_fatores_de_rede}):

\begin{itemize}

\item Latência da WAN (L): 100 e 300 ms

\item Variação da latência da WAN (V): 1 e 60\%

\item Taxa de perda de pacotes na WAN (P): 0,01 e 0,3\%

\item Taxa de duplicação de pacotes na WAN (D): 0,05 e 5\%

\item Taxa de reordenação de pacotes na WAN (O): 0,05 e 5\%

\item Variação de TCP (T): CUBIC e H-TCP

\end{itemize}

Os níveis da latências foram baseados em um estudo que relata as latências
entre os centros de processamento de dados dos Amazon Web Services
\cite{Sovran2011}.  Os centros de processamento de dados considerados são
Califórnia (EUA -- Costa Oeste), Virginia (EUA -- Costa Leste), Irlanda e
Singapura. A menor latência observada foi 82 ms entre os centros de
processamento de dados dos EUA e a maior foi 277 ms entre Irlanda e Singapura.

O mesmo estudo usado para latência apresenta um gráfico com grandes variações
de latência, chegando a máximos de até 3 ordens de grandeza em alguns períodos
curtos. O projeto PingER\footnote{\emph{Ping End-to-end Reporting} (Relatório
de Ping Fim-a-fim) é um projeto de Stanford que monitora o desempenho fim-a-fim
de enlaces de Internet, em 700 sítios e 160 países.} \cite{Pinger2013}, por sua
vez, mostra em janeiro de 2013 uma média de latência de 238,062 ms com desvio
padrão de 142,996, o que resulta em uma variação de 60\%. Os 11 meses
anteriores apresentavam valores semelhantes.

As taxas de perda foram escolhidas com base em medidas feitas pelo projeto
PingER, que mede desempenho de conexões fim-a-fim na Internet. A mediana das
perdas medidas em janeiro de 2013 foi 0,119\% e a mediana do último ano foi
0,178\%. O mesmo relatório mostra perdas bem mais altas em medições
específicas, mas este trabalho considerou que a WAN entre os dois centros de
processamento de dados é de boa qualidade, portanto não apresentaria taxas de
perda muito altas.

O mesmo estudo mostra taxas de duplicação de pacotes muitos baixas (0\%).
Embora os valores usados neste estudo tenham sido muito grandes, duplicação de
pacotes não influenciou a resposta (ver abaixo).

Duas referências sobre reordenação de pacotes foram encontradas. A primeira, o
projeto PingER, mostra taxas muito baixas -- em janeiro de 2013, média de
0,006\% e mediana de 0\%. Estudo realizado em 2003 entre sítios na China mostra
taxas de reordenação de pacotes de 3,187\% \cite{Wang2004}. Os valores usados
no experimento foram maiores, mas mesmo assim reordenação de pacotes não
influenciou a resposta (ver abaixo).

Tanto H-TCP \cite{Leith2004} quanto CUBIC \cite{Ha2008} foram projetados com
foco em redes com largura de banda e latências grandes (BDP alto). Ambos já
estavam disponíveis no Linux usado nos experimentos, sendo que TCP CUBIC é o
padrão do kernel do Linux a partir da versão 2.6.19. Eles foram escolhidos pois
são citados nas referências sobre otimizações da pilha TCP para WANs
\cite{Jones2006,ESNet2012}.

No emulador de rede, a latência define o mínimo e a variação o máximo a que ela
pode chegar. Por exemplo, ao fazer a configuração de 100 ms de latência e 60\%
de variação, o emulador vai gerar valores entre 100 ms e 160 ms aleatoriamente.
Mas redes não apresentam uma variação aleatória de latência e é possível
configurar uma distribuição da latência no emulador. No caso deste estudo, foi
usada a distribuição normal. Além disso, o emulador foi configurado com 100
Mb/so como largura de banda da WAN.

O resultado do estudo está na Tabela \ref{tab:estudo_para_fatores_de_rede}. Com
exceção dos fatores e da interação entre latência e variação de latência, todas
as outras colunas apresentavam valores nulos e foram suprimidas. As respostas
das requisições locais apresentaram CVs de 1\%, portanto as respectivas linhas
também foram suprimidas.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline

Operação & Percentil & L & V & P & D & O & T & LV\\ \hline

leitura & 90 & 72 & 21 & 1 & 0 & 0 & 0 & 6\\ \hline

escrita & 90 & 69 & 23 & 1 & 0 & 0 & 0 & 6\\ \hline

\end{tabular}

\caption{Estudo para fatores de rede. A soma para escritas não é 100\% devido a
arredondamento.} \label{tab:estudo_para_fatores_de_rede}

\end{table} A latência, a variação de latência e a interação de primeira ordem
entre elas respondem por 100\% dos resultados. Assim, os níveis escolhidos para
esses fatores nos experimentos foram:

\begin{itemize} \item Latência da WAN (ms): 0, 100, 200 e 300

\item Variação da latência da WAN (\%): 0 e 60

\end{itemize}

Níveis nulos de latência e variação da latência equivalem a ter todo o sistema
operando em uma rede local. Os resultados obtidos para esses casos foram usados
como auxílio na interpretação dos resultados, mas não foram considerados na
análise final dado que sistemas georeplicados, por definição, não operam nessas
condições.

Os valores fixados dos fatores desconsiderados foram:

\begin{itemize}

\item Taxa de perda de pacotes na WAN (\%): 0

\item Taxa de duplicação de pacotes na WAN (\%): 0

\item Taxa de reordenação de pacotes na WAN (\%): 0

\item Algoritmo de congestionamento: CUBIC

\end{itemize}

Taxas de perda, duplicação e reordenação  de pacotes foram ignoradas no estudo
final. O algoritmo de congestionamento foi fixado como CUBIC, pois esse é o
padrão no sistema Linux utilizado nos experimentos.

Apesar da taxa de reordenação de pacotes ser fixada, a ocorrência de alguns
pacotes fora de ordem é possível dada a variação da latência. Por exemplo, com
uma latência de 100 ms e uma variação de 50\%, é possível que o emulador
aplique atrasos de 120ms para um pacote e 80 ms para um outro no mesmo
milissegundo, o que faz com que o segundo pacote seja transmitido antes do
primeiro.

Um comentário final é que o mesmo estudo havia sido realizado anteriormente com
níveis de perda de pacotes 0,01\% e 1\%. Nesse estudo, a perda de pacotes era
mais influente até do que a variação da latência. Mas como redes normalmente
não apresentam taxas de perda de pacotes tão altas quanto 1\%, o estudo foi
refeito com nível máximo de 0,1\% e a perda de pacotes não afetou o resultado
nesse caso.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de carga de trabalho}
\label{sec:fatores_de_carga_de_trabalho}

Juntamente com o estudo para fatores de rede, o estudo para fatores de carga de
trabalho era um dos mais importantes, dado o objetivo deste trabalho. Os
experimentos também consideraram a latência como fator para verificar a
importância relativa entre os fatores de carga de trabalho e a rede.

Os níveis selecionados foram (entre parêenteses está o identificador do fator
na Tabela~\ref{tab:estudo_para_fatores_de_carga_de_trabalho}):

\begin{itemize}

\item Relação leitura/escrita (R): 2:1 e 10:1

\item Popularidade dos objetos (P): uniforme (a taxa de chegada de requisições
média para cada objeto é a mesma) e concentrada (a taxa de chegada segue uma
distribuição Pareto)

\item Localidade (X): 50 e 90\%

\end{itemize}

A relação leitura/escrita 2:1 representa uma carga balanceada entre os dois
tipos de operações e a 10:1 representa uma carga intensiva de leituras. A
consistência na linha do tempo pode tornar um sistema sob cargas com um maior
número de escritas inviável pois as escritas se tornam indisponíveis em caso de
falha. Assim, este estudo considera situações em que ela é competitiva quando
comparada com a consistência em momento indeterminado, por isso as relações
leitura/escrita usadas resultavam em mais leituras que escritas. Além disso, ao
atualizar um objeto na consistência em momento indeterminado, é necessário o
envio do relógio vetorial, por isso uma leitura\footnote{É possível fazer
atualizações sem relógio vetorial, mas isso cria versões concorrentes do mesmo
objeto.} é realizada pelo \emph{benchmark} antes de toda atualização. Isso
restringe a quantidade de escritas a um máximo de 50\% da carga de trabalho.  A
popularidade dos objetos uniforme representa uma taxa de chegada de requisições
média igual entre os objetos e concentrada representa uma taxa de chegada que
segue uma distribuição Pareto.

Os níveis de localidade foram escolhidos de modo a ter situações sem influência
de localidade (50\%) e com localidade alta (90\%). O valor de localidade alta é
baseado no relatado em estudo feito pelo Yahoo! em seus sistemas de produção
\cite{Cooper2008}.

Como os modos possuem comportamentos diferentes para requisições locais e
remotas, os experimentos foram executados para cada modo. O resultado para
requisições locais apresentaram CVs em torno de 0,02 para todos os modos. Isso
indica que requisições locais não sofrem influência de nenhum dos fatores. Já
requisições remotas apresentaram CVs de aproximadamente 50\% e influência da
latência de 100\% para \emph{ind2}, \emph{lt\_qqer} e \emph{lt\_rec}
(\emph{ind1} não tem requisições remotas).

A análise da relação leitura/escrita e localidade não usou percentis, mas sim a
média do tempo de resposta de todas as requisições (leituras e escritas). Isso
porque o primeiro fator diz respeito à composição entre leituras e escritas e o
segundo à composição entre requisições locais e remotas, portanto esses fatores
não fazem sentido nos percentis separados por tipo de requisição. Por exemplo,
com localidade de 50\% percebe-se que o percentil 70 representa requisições
remotas, enquanto com localidade de 90\% o mesmo percentil representa
requisições locais. Se a análise fosse feita por percentis, essa informação se
perderia e localidade nunca teria influência. O resultado do estudo está na
Tabela \ref{tab:estudo_para_fatores_de_carga_de_trabalho}.

\begin{table}[ht] \centering \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline

Modo & R & X & P & L & RX & RP & RL & XP & XL & PL & RXP & RXL & RPL & XPL &
RXPL\\ \hline \emph{ind1} & 19 & 12 & 2 & 31 & 0 & 3 & 2 & 4 & 6 & 6 & 4 & 0 &
0 & 8 & 1\\ \hline

\emph{ind2} & 50 & 0 & 0 & 39 & 0 & 0 & 11 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
\hline

\emph{lt\_qqer} & 25 & 30 & 0 & 19 & 9 & 0 & 6 & 0 & 8 & 0 & 0 & 3 & 0 & 0 &
0\\ \hline

\emph{lt\_rec} & 0 & 53 & 0 & 34 & 0 & 0 & 0 & 0 & 13 & 0 & 0 & 0 & 0 & 0 & 0\\
\hline

\end{tabular} \caption{Estudo para fatores de carga de trabalho.  }
\label{tab:estudo_para_fatores_de_carga_de_trabalho}

\end{table}

Como esperado, localidade e latência influenciam as respostas em geral. Uma
observação é o fato de inclusive \emph{ind1} ser afetada por latência. Isso
provavelmente é resultado dos mecanismos de replicação e correção de leituras
serem afetados pela latência.

O impacto de popularidade dos objetos é praticamente nulo. Talvez em uma
situação em que o sistema recebesse uma carga maior, como no caso de um teste
de sobrecarga, esse fator passasse a ser influente. Como não é o caso, ele foi
desconsiderado e fixado no valor que simplifica o entendimento dos resultados.
Em trabalhos futuros, experimentos podem ser realizados com o sistema sob carga
mais alta para verificar se a influência de popularidade aumenta.  Apesar de
alguns modos aparentemente sofrerem impacto considerável da relação
leitura/escrita, esse impacto é consequência da relação entre requisições
locais e remotas. Para \emph{ind1}, tanto leituras quanto escritas são locais e
a relação leitura/escrita e suas interações com outros fatores impacta pouco
esse modo.  Para \emph{lt\_rec}, leituras e escritas são locais ou remotas
dependendo da localidade e a relação leitura/escrita não impacta esse modo.
Para \emph{ind2}, todas as leituras são locais e metade das escritas é remota,
portanto quando a relação leitura/escrita muda, a relação entre requisições
locais e remotas muda proporcionalmente -- como esperado, esse modo é impactado
pela relação leitura/escrita. A mesma observação vale para \emph{lt\_qqer}, que
tem todas as leituras locais e escritas dependendo da localidade, e também
sofre impacto da relação leitura/escrita.

Caso o mecanismo de armazenamento fosse disco em vez de memória, a relação
leitura/escrita provavelmente sofreria impacto de fato. Isso porque escritas
seriam afetadas pelo tempo de escrita no disco, enquanto leituras poderiam ser
mais rápidas pois parte delas seriam servidas a partir do cache de disco.  Mas
como não é esse o caso, a diferença relevante é a relação entre requisições
locais e remotas.

Dessa forma, só foram escolhidos níveis para localidade:

\begin{itemize}

\item Localidade (\%): 50 e 90

\end{itemize}

Os valores fixados dos fatores desconsiderados foram:

\begin{itemize}

\item Relação leitura/escrita: 2:1 \item Popularidade dos objetos: uniforme

\end{itemize}

O valor da relação leitura/escrita é um balanço razoável entre leituras e
escritas. O valor de popularidade é o mais simples para a interpretação dos
resultados.
%% ------------------------------------------------------------------------- %%
\subsection{Fatores selecionados} \label{sec:fatores_selecionados}

Os fatores selecionados nos estudos 2\textsuperscript{k} compuseram o estudo
final e são apresentados junto com seus níveis na
Tabela~\ref{tab:fatores_e_niveis_do_estudo_final}.

\begin{table}[ht] \centering \begin{tabular}{|l|c|c|} \hline

\multicolumn{1}{|c|}{Fator} & \multicolumn{1}{|c|}{Níveis} &
\multicolumn{1}{|c|}{Total de níveis}\\ \hline

Modo & \emph{ind1}, \emph{ind2}, \emph{lt\_qqer} e \emph{lt\_rec} & 4\\ \hline

Latência da WAN (ms) & 0, 100, 200 e 300 & 4\\ \hline

Variação da latência da WAN (\%) & 0 e 60 & 2\\ \hline

Localidade & 50\% e 90\% & 2\\ \hline

\end{tabular}

\caption{Fatores e níveis do estudo final.}
\label{tab:fatores_e_niveis_do_estudo_final}

\end{table}

Esse número de fatores e níveis resultou em um total de 64 experimentos.

\section{Análise dos Resultados}

\section{Trabalhos Relacionados}

\section{Conclusões}

\section{Agradecimentos}

Os experimentos apresentados neste trabalho foram realizados utilizando a
plataforma para experimentos Grid'5000, desenvolvida pela ação de
desenvolvimento ALADDIN INRIA com o apoio do CNRS, RENATER e várias
universidades, bem como outros organismos de financiamento (ver
\url{https://www.grid5000.fr}).

%\begin{figure}[ht] \centering \includegraphics[width=.5\textwidth]{fig1.jpg}
%\caption{A typical figure} \label{fig:exampleFig1} \end{figure}
%
%\begin{figure}[ht] \centering \includegraphics[width=.3\textwidth]{fig2.jpg}
%\caption{This figure is an example of a figure caption taking more than one
%line and justified considering margins mentioned in Section~\ref{sec:figs}.}
%\label{fig:exampleFig2} \end{figure}

% \begin{table}[ht] \centering \caption{Variables to be considered on the
% evaluation of interaction techniques} \label{tab:exTable1}
% \includegraphics[width=.7\textwidth]{table.jpg} \end{table}

\section{Referências} \bibliographystyle{sbc} \bibliography{bibliografia}

\end{document}
